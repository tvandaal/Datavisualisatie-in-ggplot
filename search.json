[
  {
    "objectID": "01_intro.html",
    "href": "01_intro.html",
    "title": "Introductie van ggplot2",
    "section": "",
    "text": "Je vraagt je misschien af waarom je de moeite zou doen om ggplot2 te leren? Er zitten immers heel wat plot-functies ingebouwd in R. Er is echter een heel goede reden waarom wij fan zijn van ggplot2. Vooraleer we aan de slag gaan met ggplot2, leggen we daarom eerst uit waarom het de moeite loont om ggplot2 te leren (Sectie 1). Vervolgens gaan we in Sectie 2 kort in op de Grammar of Graphics (de taal waarop ggplot2 gebaseerd is) en zorgen dat je klaar bent om met ggplot2 aan de slag gaan (Sectie 3). Ten slotte maak je ook je eerste visualisaties in Sectie 4 en Sectie 5.",
    "crumbs": [
      "Introductie van `ggplot2`"
    ]
  },
  {
    "objectID": "01_intro.html#ggplot2-en-de-tidyverse",
    "href": "01_intro.html#ggplot2-en-de-tidyverse",
    "title": "Datavisualisatie met ggplot2",
    "section": "4 ggplot2 en de tidyverse",
    "text": "4 ggplot2 en de tidyverse\nggplot2 is een R-package speciaal gecreëerd voor datavisualisatie.",
    "crumbs": [
      "Introductie van `ggplot2`"
    ]
  },
  {
    "objectID": "01_intro.html#de-plotfuncties-in-r",
    "href": "01_intro.html#de-plotfuncties-in-r",
    "title": "Introductie van ggplot2",
    "section": "1 De plotfuncties in R?",
    "text": "1 De plotfuncties in R?\nWie een beetje vertrouwd is met R weet dat er standaard verschillende plot-functies in R zitten. Voorbeelden daarvan zijn de functies hist(), boxplot() en uiteraard ook plot(). Hieronder vind je een voorbeeld van een histogram, een boxplot en een scatterplot gecreëerd met deze functies.\n\nhist()boxplot()plot()\n\n\n\nhist(data$x, xlab = \"x\") \n\n\n\n\n\n\n\n\n\n\n\nboxplot(data$y, xlab = \"y\") \n\n\n\n\n\n\n\n\n\n\n\nplot(data$x, data$y, xlab = \"x\", ylab = \"y\")\n\n\n\n\n\n\n\n\n\n\n\nDe plot()-functie is bijzonder omdat de output van deze functie zich aanpast aan de input die het krijgen. Geef je plot() twee kwantitatieve variabelen mee? Dan tovert plot() een scatterplot te voorschijn (zoals in het voorbeeld hierboven). Krijgt plot() een tabel als input? Dan wordt er een staafdiagram gecreëerd. De plot-functies die standaard in R zitten, bieden dus al de nodige mogelijkheden. Waarom is er dan nood aan een bijkomend R-package dat zich specifiek richt op visualisatie?\nggplot2 biedt enkele voordelen ten opzichte van de plot-functies die standaard in R zitten. Ten eerste is ggplot2 veel flexibeler in gebruik dan de standaard plot-functies. De functies hist() of boxplot() laten bijvoorbeeld alleen maar toe om een specifiek soort grafiek te creëren. Je kan wel zaken aanpassen (bv. de kleur van een histogram) of toevoegen aan de plots (bv. een titel), maar deze mogelijkheden zijn vrij beperkt. Daarnaast is het ook niet zo evident om alle soorten visualisaties te creëren met de standaard plot-functies. ggplot2 en de vele packages die erop verderbouwen laten je toe om elk type grafiek te creëren dat je wenst. Ten slotte is het ggplot2 gebaseerd op een theorie over datavisualisatie, de Grammar of Graphics. Zoals de naam van de theorie suggereert, is ggplot2 gebaseerd op een generieke ‘grammatica’ voor het creëren van visualisaties. Dit maakt het gebruik van ggplot2 veel intuïtiever dan dat van de standaard plot-functies in R.",
    "crumbs": [
      "Introductie van `ggplot2`"
    ]
  },
  {
    "objectID": "01_intro.html#grammar-of-graphics",
    "href": "01_intro.html#grammar-of-graphics",
    "title": "Introductie van ggplot2",
    "section": "2 Grammar of graphics",
    "text": "2 Grammar of graphics\nHet package ggplot2 volgt de principes van de Grammar of Graphics. De Grammar of Graphics is een ‘taal’ ontworpen door Leland Wilkinson om grafieken te creëren. Wilkinson was een Amerikaanse statisticus en expert op het gebied van datavisualisatie. Hij introduceerde het concept in zijn boek “The Grammar of Graphics” (1999). Volgens de Grammar of Graphics kan elke visualisatie worden opgesplitst in dezelfde componenten (layers in Grammar of Graphics-taal). Voorbeelden van zulke layers zijn data, geometrische objecten en facetten. De Grammar of Graphics is dus een universeel systeem om visualisaties te creëren dat de basis vormt voor verschillende moderne visualisatietools (waaronder dus ook ggplot2).\nHet basisidee achter ggplot2 is dat je een plot in laagjes opbouwt. Er worden zeven verschillende soorten laagjes (layers) onderscheiden: data, aesthetics (bv. variabele op de x- en y-as), geometries (bv. histogram, lijngrafiek), facets, statistics (bv. regressielijn), coordinates en theme. Elke laag voegt een nieuw element toe aan de plot. De animatie hieronder is overgenomen van Thomas de Beus en illustreert hoe een ggplot wordt opgebouwd aan de hand van verschillende layers.\n\nEen visualisatie maken in ggplot2 doe je dus laagje per laagje, een beetje zoals je een cake bakt. Op de figuur hieronder zie je hoe elk onderdeel van de cake overeenkomt met een layer in ggplot2. Als je een cake bakt, start je altijd met het leggen van de basis. In ggplot2 doe je dat met de functie ggplot(). Elke visualisatie start dus met deze functie. Vervolgens specificeer je de ingrediënten met behulp van de functie aes() en de smaken met de functie scales. Dan voeg je laagjes toe aan je cake in de vorm van een geom. Ten slotte kan je de cake naar eigen believen afwerken (‘stylen’) door middel van de functie theme.    Figuur overgenomen van Tanya Shapiro",
    "crumbs": [
      "Introductie van `ggplot2`"
    ]
  },
  {
    "objectID": "01_intro.html#ggplot2-in-een-notendop",
    "href": "01_intro.html#ggplot2-in-een-notendop",
    "title": "Introductie van ggplot2",
    "section": "4 ggplot2 in een notendop",
    "text": "4 ggplot2 in een notendop\nNu je een beetje vertrouwd bent met de penguin-data kunnen we aan de slag met ggplot2!\n\n4.1 Data en aesthetics\nJe start in ggplot2 steeds met de functie ggplot(). In deze functie geef je aan welke data je wil gebruiken (data = penguins) en je specificeert ook de aesthetics. De aesthetics vormen de ingrediënten van je plot. Het zijn de variabelen die je wil plotten. De aesthetics specificeren doe je aan de hand van de functie aes(). In dit geval willen we de variabele flipper_length_mm op de x-as en de variabele body_mass_g op de y-as.\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Zorg dat de packages tidyverse en palmerpenguins geladen zijn. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n\n  ## Stap 1: data\n  data = penguins,\n  \n  ## Stap 2: aesthetics specificeren (mapping)\n  aes(\n    x = flipper_length_mm,\n    y = body_mass_g)\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.2 Geometries\nDe vorige code levert een lege plot op! Dit komt omdat je alleen de basis voor je plot hebt gelegd (met de functie ggplot()), maar niet hebt aangegeven welk geometrisch object (geom in ggplot2-taal) je wilt gebruiken. Een geom representeert de visuele elementen die worden gebruikt om gegevens weer te geven in de plot. Elke geom komt overeen met een specifiek type grafische representatie, zoals punten, lijnen, balken of gebieden. Geoms bepalen dus hoe de gegevens visueel worden weergegeven. In ons voorbeeld voegen we de geom_point() functie toe. Deze functie geeft elk datapunt weer als een punt op de plot? Vul je code aan en evalueer het resultaat. Je krijgt een warning. Wat betekent deze warning?\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n\n  ## Stap 1: data\n  data = penguins,\n  \n  ## Stap 2: aesthetics specificeren (mapping)\n  aes(\n    x = flipper_length_mm,\n    y = body_mass_g)\n) +\n  ## Stap 3: voeg geometry toe\n  geom_point()\n\n\n\n\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\nDe warning wijst erop dat er twee ontbrekende observaties zijn (en dat deze uiteraard niet geplot zijn).\n\n\n4.3 Facets\nStel dat we het verband tussen het lichaamsgewicht en vleugellengte per pinguïnsoort willen plotten. We willen m.a.w een aparte scatterplot per soort (small multiples). Dit kan je heel eenvoudig realiseren met behulp van de functie facet_wrap(). Tussen de haakjes geef je aan op basis van welke variabele de facets moeten worden gecreëerd (in dit geval species). Deze variabele dient vooraf gegaan te worden door een tilde (~).\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n\n  ## Stap 1: data\n  data = penguins,\n  \n  ## Stap 2: aesthetics specificeren (mapping)\n  aes(\n    x = flipper_length_mm,\n    y = body_mass_g)\n) +\n  ## Stap 3: voeg geometry toe\n  geom_point() +\n  \n  ## Stap 4: definieer facets\n  facet_wrap(~species)\n\n\n\n\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.4 Theme\nIn een laatste stap passen we het plot-thema aan. Als je geen plot-thema meegeeft, dan gebruikt deze het default plot-thema. Dit plot-thema heeft echter een grijze achtergrond die verder niets bijdraagt aan de plot (chart junk!). Verander daarom het plot-thema naar theme_minimal(). Voeg dit plot-thema standaard toe aan alle plots die je creëert!\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n\n  ## Stap 1: data\n  data = penguins,\n  \n  ## Stap 2: aesthetics specificeren (mapping)\n  aes(\n    x = flipper_length_mm,\n    y = body_mass_g)\n) +\n  ## Stap 3: voeg geometry toe\n  geom_point() +\n  \n  ## Stap 4: definieer facets\n  facet_wrap(~species) +\n  \n  ## Stap 5: pas thema aan\n  theme_minimal()\n\n\n\n\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).",
    "crumbs": [
      "Introductie van `ggplot2`"
    ]
  },
  {
    "objectID": "05_layout.html",
    "href": "05_layout.html",
    "title": "Lay-out van een ggplot aanpassen",
    "section": "",
    "text": "Dit hoofdstuk gaat in op hoe je de lay-out van de verschillende componenten van een visualisatie kan aanpassen. We werken daarbij met de puntenwolk die we in hoofdstuk vier maakten.",
    "crumbs": [
      "Visualisatie in stijl"
    ]
  },
  {
    "objectID": "05_layout.html#plot-thema-aanpassen",
    "href": "05_layout.html#plot-thema-aanpassen",
    "title": "Lay-out van een ggplot aanpassen",
    "section": "1 Plot thema aanpassen",
    "text": "1 Plot thema aanpassen\nIn ggplot2 zitten een aantal ingebouwde plot-thema’s. Zoals aangegeven in het eerste hoofdstuk van dit OLP gebruik je als default plot-thema bij voorkeur theme_minimal(). De onderstaande thema’s zitten echter ook standaard in ggplot2:\n\ntheme_bw()\n\ntheme_linedraw()\n\ntheme_light()\n\ntheme_dark()\n\ntheme_classic()\n\ntheme_void()\n\nVervang theme_minimal() in de code hieronder en test de andere thema’s zelf uit!",
    "crumbs": [
      "Visualisatie in stijl"
    ]
  },
  {
    "objectID": "05_layout.html#anatomie-van-een-ggplot",
    "href": "05_layout.html#anatomie-van-een-ggplot",
    "title": "Lay-out van een ggplot aanpassen",
    "section": "2 Anatomie van een (gg)plot",
    "text": "2 Anatomie van een (gg)plot\nHoewel de ingebouwde thema’s handig zijn om van te vertrekken, wil je vaak toch nog bepaalde aspecten van de lay-out naar je hand zetten. Dit kan je doen met behulp van de functie theme(). Omdat je via deze functie echt elke component van een plot kan aanpassen, is het belangrijk om een zicht te krijgen op die verschillende componenten en de gepaste terminologie ervoor.\nDe figuur hieronder is overgenomen van de blog van Isabella Benabaye en geeft een overzicht van de verschillende componenten van de lay-out van een ggplot. Je kan deze figuur hier ook downloaden als pdf. Bekijk de figuur en probeer de verschillende componenten van de plot te classificeren. Welke groepen onderscheid jij?\n\n\n\n\n\n\n\n\n\nJe kan de componenten classificeren in de volgende ‘groepen’. Ten eerste bestaan heel wat componenten uit tekst. Voorbeelden hiervan zijn de titel van de plot (plot.title in ggplot2 taal), maar ook de labels op de assen (axis.text in ggplot2 taal) en de voetnoot (plot.caption in ggplot2 taal). Daarnaast zijn er ook heel wat componenten die eigenlijk lijnen weergeven. De gridlijnen (panel.grid in ggplot2 taal) zijn daar het duidelijkste voorbeeld van, maar ook de beide assen zijn niet meer of minder dan een lijn (axis.line in ggplot2 taal). Een derde groep componenten zijn rechthoeken. In de figuur hierboven is de achtergrond van de legende daar een voorbeeld van (legend.background in ggplot2 taal).",
    "crumbs": [
      "Visualisatie in stijl"
    ]
  },
  {
    "objectID": "05_layout.html#de-functie-theme",
    "href": "05_layout.html#de-functie-theme",
    "title": "Lay-out van een ggplot aanpassen",
    "section": "3 De functie theme()",
    "text": "3 De functie theme()\nDe functie theme() maakt gebruik van de indeling in de tekst-, lijn- en rechthoekige elementen om de verschillende componenten van een plot aan te passen. Deze elementen zijn ‘vertaald’ naar verschillende functies:\n\nelement_text(): aanpassen van tekst-componenten\n\nelement_line(): aanpassen van lijn-componenten\n\nelement_rect(): aanpassen van rechthoekige-componenten\n\nHieronder wordt het gebruik van de verschillende elementen geïllustreerd.\n\n3.1 Tekst-componenten aanpassen\nOm componenten die tekst weergeven aan te passen via theme(), is het belangrijk dat je het argument kent dat naar elk van deze componenten verwijst. Hieronder vind je een overzicht van de belangrijkste tekst-componenten:\n\nplot.title: de titel van de plot\n\nplot.subtitle: de subtitel van de plot\n\nplot.caption: een voetnoot bij de plot\n\naxis.title: de titel van beide assen (beide titels krijgen dezelfde lay-out)\n\naxis.title.x en axis.title.y: de titel van de x-as en van de y-as (op die manier kan je elke titel een andere lay-out geven)\n\naxis.text: de labels op beide assen (de labels op beide assen krijgen dezelfde lay-out)\n\naxis.text.x en axis.text.y: de labels op x-as en de y-as (op die manier kan je de labels op beide assen een andere lay-out geven)\n\nlegend.title: de titel van de legende\n\nOm de lay-out van elk van deze componenten te specificeren, kan je gebruik maken van de element_text()-functie. Daarbij zijn de drie belangrijkste argumenten: color (kleur van de letters), size (grootte van de letters) en face (vet = \"bold\", cursief = \"italic\", vet en cursief = \"bold.italic\"). Als je een bepaalde tekstelement wil weglaten, dan vervang je element_text() door element_blank().\nIn de code hieronder kregen alle tekstelementen dezelfde lay-out. Experimenteer met de verschillende mogelijkheden. Probeer ook eens één van de elementen te verwijderen met behulp van de functie element_blank(). Kan je de titels van de x- en de y-as ook een andere lay-out geven?\n\n\n\n\n\n\n\n\n3.2 Lijn-componenten aanpassen\nHet aanpassen van lijn-componenten gebeurt op een gelijkaardige manier waarbij je gebruik maakt van de functie element_line(). Hieronder vind je een lijst van de belangrijkste componenten die je op deze manier kan aanpassen:\n\npanel.grid.major: de gridlijnen die vanuit de breaks op beide assen vertrekken (beiden krijgen dezelfde lay-out)\n\npanel.grid.major.x en panel.grid.major.y: de gridlijnen die vanuit de breaks op de x- en y-as vertrekken (op die manier kan je de gridlijnen vertrekkend vanuit beide assen een andere lay-out geven)\n\npanel.grid.minor: de gridlijnen die tussen de ‘major’ gridlijnen liggen (beiden krijgen dezelfde lay-out)\npanel.grid.minor.x en **`panel.grid.minor.y: de gridlijnen die tussen de ‘major’ gridlijnen liggen op de x- en de y-as (op die manier kan je de ‘minor’ gridlijnen op de beide assen een andere lay-out geven)\n\naxis.line: de assen (beiden krijgen dezelfde lay-out)\n\naxis.line.x en axis.line.y: de x- en de y-as (op die manier kan je beiden een andere lay-out geven)\n\naxis.ticks: de lijntjes die bij de breaks op beide assen staan (beiden krijgen dezelfde lay-out)\n\naxis.ticks.x en axis.ticks.y: de lijntjes die bij de breaks op de x- en de y-as staan (op die manier kan je beiden een andere lay-out geven)\n\nOm de lay-out van deze elementen aan te passen, maak je gebruik van de functie element_line() en de argumenten color (kleur van de lijn), linewidth (dikte van de lijn) en linetype (lijntype: “solid”, “dashed”, “dotted”, “dotdash”, “longdash”, “twodash”, “blank”). Om een element weg te halen, gebruik je opnieuw de functie element_blank().\nExperimenteer in de code hieronder met de lay-out van de gridlijnen. Je kan uiteraard ook de code toevoegen om de lay-out van de andere lijn-componenten aan te passen.\n\n\n\n\n\n\n\n\n3.3 Rechthoekige componenten aanpassen\nEr zijn slechts een beperkt aantal rechthoekige elementen. Je kan deze elementen aanpassen via de functie element_rect(). De twee belangrijkste elementen zijn panel.background en legend.background. Via deze argumenten kan je respectievelijk de achtergrond van de plot en van de legende aanpassen. Je kan daarbij de kleur van de omtrek (color) en de opvulkleur (fill) aanpassen. In de code hieronder zijn beide argumenten toevoegen aan de theme()-functie. Experimenteer met verschillende waardes voor fill en color en kijk wat er gebeurt. Merk op dat je ook kan aangeven dat geen opvulling of omtrekkleur wil. Hiervoor gebruik je NA.\n\n\n\n\n\n\n\n\n3.4 Positie van de legende, titel en subtitel aanpassen\nDe argumenten van de functie theme() die de positie van de legende (legend.position), de titel (plot.title.position) en de subtitel (plot.subtitle.position) bepalen, maken geen gebruik van één van de elementen die hierboven werden uitgelegd. De positie van de legende kan je bepalen via \"right\" (default-waarde), \"left\", \"top\", \"bottom\" of \"none\" (verwijderd de legende). Voor de positie van de titel kan je alleen kiezen uit \"plot\" of \"panel\". Test de verschillende opties hieronder uit.",
    "crumbs": [
      "Visualisatie in stijl"
    ]
  },
  {
    "objectID": "05_layout.html#overzicht-van-functies-en-argumenten-uit-hoofdstuk-5",
    "href": "05_layout.html#overzicht-van-functies-en-argumenten-uit-hoofdstuk-5",
    "title": "Lay-out van een ggplot aanpassen",
    "section": "4 Overzicht van functies en argumenten uit hoofdstuk 5",
    "text": "4 Overzicht van functies en argumenten uit hoofdstuk 5\nDe onderstaande functies en argumenten zijn in dit hoofdstuk aan bod gekomen:\n\nfunctie theme() en de argumenten plot.title, plot.subtitle plot.caption, axis.title, axis.title.x, axis.title.y, axis.text, axis.text.x, axis.text.y, panel.grid.major, panel.grid.major.x, panel.grid.major.y, panel.grid.minor, panel.grid.minor.x, panel.grid.minor.y, axis.line, axis.line.x, axis.line.y, axis.ticks, axis.ticks.x, axis.ticks.y, panel.background, legend.background, legend.position en plot.title.position\n\nfunctie element_text() en de argumenten color, face en size\n\nfunctie element_line() en de argumenten linewidth, linetype en color\nfunctie element_rect() en de argumenten fill en color\n\nLet op! De meeste functies beschikken over veel meer argumenten dan deze die in dit hoofdstuk aan bod zijn gekomen. Om hier een overzicht van te krijgen, kan je de help-functie gebruiken. De functie theme() heeft tientallen argumenten die het mogelijk maken om elke component van een visualisatie te lay-outen. Je vindt een overzicht van alle argumenten via deze link.",
    "crumbs": [
      "Visualisatie in stijl"
    ]
  },
  {
    "objectID": "02_numeriek.html",
    "href": "02_numeriek.html",
    "title": "Eén numerieke variabele visualiseren",
    "section": "",
    "text": "Er bestaan verschillende manieren om de verdeling van een numerieke variabele voor te stellen. Twee veel gebruikte grafiektypes zijn een histogram en een boxplot. Dit hoofdstuk focust op hoe je deze grafieken kan maken met ggplot2. Eerst tonen we hoe je een histogram maakt (Sectie 1). Vervolgens leer je een boxplot maken (Sectie 2). In beide gevallen maak je daarbij gebruik van de pinguïndata, en meer specifiek van de variabele flipper_length_mm (vleugellengte). Op het einde van dit hoofdstuk vind je een overzicht van de verschillende functies en hun argumenten die je in dit hoofdstuk leerde (Sectie 3).",
    "crumbs": [
      "Visualiseren van één numerieke variabele"
    ]
  },
  {
    "objectID": "02_numeriek.html#histogram",
    "href": "02_numeriek.html#histogram",
    "title": "Eén numerieke variabele visualiseren",
    "section": "1 Histogram",
    "text": "1 Histogram\nEen eerste mogelijkheid om de verdeling van de variabele flipper_length_mm te visualiseren is een histogram. Hieronder vind je een voorbeeldhistogram dat je op het einde van dit deel ook zelf zal kunnen maken.\n\n\n\n\n\n\n\n\n\n\n1.1 Histogram met geom_histogram()\nOm een histogram te plotten, maak je gebruik van de functie geom_histogram(). Deze functie heeft één ingrediënt (aesthetic) nodig: een x-variabele (x = flipper_length_mm).\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Zorg dat de packages tidyverse en palmerpenguins geladen zijn. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n  data = penguins,\n  aes(\n    x = flipper_length_mm,\n    )\n  ) +\n  geom_histogram() +\n  theme_minimal()\n\n\n\n\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\n\n\nBij het uitvoeren van de code krijg je zowel een warning als een boodschap van ggplot. De warning verwijst naar twee ontbrekende waarden in de variabele flipper_length_mm. Dit kan je checken via summary().\n\nsummary(penguins$flipper_length_mm)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  172.0   190.0   197.0   200.9   213.0   231.0       2 \n\n\nJe krijgt ook een boodschap van ggplot2, namelijk stat_bin() using bins = 30. Pick better value with binwidth. Dit verwijst naar de manier waarop geom_histogram() de breedte van de ‘bins’ bepaalt. Meer informatie daarover vind je hieronder.\n\n\n1.2 Basisargumenten geom_histogram()\nHet histogram dat je net maakte, bevat de absolute frequenties op de y-as. Als je een histogram met relatieve frequenties wil plotten, dan voeg je een tweede ingrediënt (aesthetic) toe aan de ggplot()-functie: y = after_stat(density). In het code hieronder zijn er nog enkele andere argumenten toegevoegd aan de functie geom_histogram(). Je vindt hieronder een overzicht van deze argumenten en hun betekenis:\n\nbin: geeft het aantal bins dat het histogram moet bevatten weer. Als je dit argument en het argument binwidth niet specificeert, dan worden er standaard 30 bins geplot. (Dat was de boodschap die ggplot2 je hierboven meegaf.)\n\nbinwidth: geeft de breedte van de bins in het histogram weer. Als je het argument binwidth gebruikt, wordt de waarde die je bij bins ingeeft genegeerd.\n\nfill: opvulkleur van het histogram\n\ncolor: kleur van de lijn rondom het histogram\n\nLaat de code hieronder lopen en bekijk het histogram. Speel vervolgens met de waarden van de argumenten bins, binwidth, fill en color en kijk wat er gebeurt.\n\n\n\n\n\n\n\n\n1.3 Breaks op de x- en y-as specificeren\nTot nu toe bepaalde ggplot2 zelf de breaks (intervallen) op de x- en y-as. Je kan deze echter ook zelf specificeren. Daarvoor maak je gebruik van de functie scale_x_continuous() en scale_y_continuous(). Je voegt aan beide functies het argument breaks = ... toe. Op de plaats van de drie puntjes geef je dan aan welke breaks er moeten worden geplot.\nDe code hieronder geeft aan dat op de x-as breaks geplaatst moeten worden van de waarde 170 tot en met de waarde 230, telkens met een sprong van 10. Dit gebeurt door de drie puntjes te vervangen door seq(170, 230, 10). Op de y-as wordt er een sequentie in sprongen van 10 geplot (seq(10, 50, 10)). Aan deze sequentie wordt de waarde 57 ‘geplakt’ (met de functie c()) omdat dit de hoogst waargenomen frequentie is.\nLaat de code hieronder lopen en bekijk het histogram. Specificeer zelf andere breaks en bekijk het effect ervan. (Merk op dat dit terug een histogram is dat de absolute frequentie voorstelt.)\n\n\n\n\n\n\nJe hebt misschien opgemerkt dat er nog een argument is toegevoegd aan geom_histogram(): alpha = .8. Met dit argument bepaal je de transparantie van het histogram (meer specifiek van de fill-color. Standaard is de waarde voor dit argument 1 (niet-transparant). Door een waarde lager dan 1 mee te geven, verhoog je dus de transparantie van het histogram. Met de theme()-functie kan je de lay-out van de plot aanpassen. In dit geval zijn een deel van de gridlijnen (‘minor’ gridlijnen) verwijderd (panel.grid.minor = element_blank) en ook de belangrijkste gridlijnen (‘major’ gridlijnen) vertrekkend vanuit de x-as verwijderd (panel.grid.major.x = element_blank). In hoofdstuk 5 gaan we dieper in op de theme()-functie.\n\n\n1.4 Titel, subtitel en titel van de assen toevoegen\nVia de functie labs() kan je de labels van zowel de titel (title), subtitel (subtitle), als de namen van de x- en y-as aanpassen. Bedenk gepaste titels voor het histogram over de vleugellengte van de pinguïns en vul de code hieronder aan.\n\n\n\n\n\n\nAan de theme()-functie zijn twee argumenten toegevoegd om de lay-out van de tekst in de titel (plot.title = element_text(face = \"bold\")) en de subtitel (plot.subtitle = element_text(face = \"italic\")) aan te passen.",
    "crumbs": [
      "Visualiseren van één numerieke variabele"
    ]
  },
  {
    "objectID": "02_numeriek.html#boxplot",
    "href": "02_numeriek.html#boxplot",
    "title": "Eén numerieke variabele visualiseren",
    "section": "2 Boxplot",
    "text": "2 Boxplot\nEen andere mogelijkheid om de verdeling van de variabele flipper-_length_mm te visualiseren is een boxplot. Een voorbeeld van een boxplot (met de data erover geplot) vind je hieronder.\n\n\n\n\n\n\n\n\n\n\n2.1 Boxplot met geom_boxplot()\nOm een boxplot te maken, gebruik je de functie geom_boxplot(). Deze functie heeft één ingrediënt (aesthetic) nodig: een x-variabele (x = flipper_length_mm) of een y-variabele (y = flipper_length_mm). Test met behulp van de code hieronder uit wat het effect is van de x in y veranderen.\n\n\n\n\n\n\n\n\n\n\n2.2 Basisargumenten geom_boxplot()\nIn het staafdiagram hieronder zijn er vier argumenten toegevoegd aan de functie geom_bar():\n\noutliers: of er al dan niet outliers geplot moeten worden (TRUE or FALSE)\n\noutlier.color: bepaalt de kleur van outliers\n\nfill: bepaalt de opvulkleur van de boxplot\n\ncolor: bepaalt de kleur van de lijn rondom de boxplot\n\nalpha: bepaalt de transparantie van de box van de boxplot (niet-transparant = 1, volledig transparant = 0)\n\nLaat de code hieronder lopen en bekijk de boxplot. Speel met de waarden van de argumenten fill, color en alpha en bekijk wat er gebeurt. (Er zijn geen outliers! Spelen met de waarde van de argumenten outliers en outlier.color heeft in dit geval dus geen zin.)\n\n\n\n\n\n\n\n\n2.3 De x-as aanpassen\nOm de breaks op de x-as aan te passen, maken we opnieuw gebruik van de functie scale_x_continuous() en het argument breaks. Specificeer dit argument in de code hieronder zodanig dat de breaks starten op 170 tot 230 lopen met sprongen van 5. Door ook het argument position = \"top\" aan scale_x_continuous() toe te voegen wordt de x-as bovenaan de boxplot geplaatst.\n\n\n\n\n\n\nDe waarden op de y-as dragen in dit geval niets meer bij. Deze zijn verwijderd door het argument axis.text.y = element_blank() toe te voegen aan de theme()-functie.\n\n\n2.4 De data toevoegen met geom_jitter()\nEen boxplot communiceert de verdeling van de variabele flipper_length_mm door enkele kengetallen samen te vatten. Dit maakt dat de onderliggende patronen in de data verborgen blijven. De onderstaande boxplots lijken identiek, maar ze verbergen een heleboel zaken. Je kan bijvoorbeeld niet aflezen hoe groot de steekproef is waarop elke boxplot gebaseerd is.\n\n\n\n\n\n\n\n\n\nOok de verdeling van de data zelf blijft onzichtbaar in een boxplot. Om dit op te lossen, kan je de data zelf ook toevoegen aan de boxplot. Dit kan je doen met behulp van geom_point() of geom_jitter(). Hieronder vind je een voorbeeld van beiden toegepast op de boxplot van vleugellengte.\n\nplot_point &lt;- ggplot(\n  data = penguins,\n  aes(\n    x = flipper_length_mm\n    )\n  ) +\n  geom_boxplot(\n    outliers = TRUE,\n    outlier.color = \"darkred\",\n    fill = \"grey\",\n    color = \"black\",\n    alpha = 0.8\n  ) +\n  geom_point(\n    aes(y = 0),\n    shape = 1,\n    alpha = 0.3\n    ) +\n  scale_x_continuous(\n    breaks = seq(170, 230, 10),\n    position = \"top\"\n  ) + \n  labs(\n    x = \"Vleugellengte (in mm)\",\n    title = \"Data geplot met geom_point\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    axis.text.y = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor = element_blank()\n  )\n\nplot_jitter &lt;- ggplot(\n  data = penguins,\n  aes(\n    x = flipper_length_mm\n    )\n  ) +\n  geom_boxplot(\n    outliers = TRUE,\n    outlier.color = \"darkred\",\n    fill = \"grey\",\n    color = \"black\",\n    alpha = 0.8\n  ) +\n  geom_jitter(\n    aes(y = 0),\n    height = .1,\n    shape = 1,\n    alpha = .3\n    ) +\n  scale_x_continuous(\n    breaks = seq(170, 230, 10),\n    position = \"top\"\n  ) + \n  labs(\n    x = \"Vleugellengte (in mm)\",\n    title = \"Data geplot met geom_jitter\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    axis.text.y = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor = element_blank()\n  )\n\nlibrary(patchwork)\nplot_point + plot_jitter +\n  plot_annotation(tag_levels = \"1\", tag_suffix = \")\")\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nHet verschil tussen beide functies is dat geom_jitter() een beetje ‘ruis’ toevoegt aan elk datapunt zodat de punten niet precies boven op elkaar geplot worden. Dat laatste is wel het geval bij het gebruik van geom_point (plot 1). Op die manier is het moeilijk in te schatten hoeveel datapunten er zijn.\nAls je hierboven de code van de rechterplot bekijkt, dan merk je dat je er één aesthetic is toegevoegd aan de functie geom_jitter() (y = 0). De variabele op de x-as blijft dezelfde als in de ggplot-functie (x = flipper_length_mm). Als je de x-variabele niet had gespecificeerd, had geom_jitter() dezelfde variabele gebruikt als je hebt aangegeven in de ggplot()-functie, de variabele flipper_length_mm dus. (Alle geoms ‘erven’ de aesthetics uit de ggplot()-functie.)\nVerder zijn er ook argumenten meegegeven om de hoeveelheid ‘ruis’ in verticale richting weer te geven (height = 0.1). Ook de grootte van elk datapunt (size = 1), de vorm die elk datapunt weergeeft (shape = 1) en de transparantie ervan (alpha = 0.3) is vastgelegd. In hoofdstuk 3 leer je meer over de verschillende shapes die beschikbaar zijn in R. Hieronder vind je de code terug. Speel met de verschillende waardes in de functie geom_jitter() en kijk wat er gebeurt!\n\n\n\n\n\n\nBen je benieuwd naar hoe verschillend of gelijkend de dataset achter de drie identieke boxplots is? Neem dan een kijkje op de blog van Cedric Schérer. Dit is één van de ggplot-wizards die regelmatig workshops geeft over ggplot2.",
    "crumbs": [
      "Visualiseren van één numerieke variabele"
    ]
  },
  {
    "objectID": "02_numeriek.html#overzicht-van-functies-en-argumenten-uit-hoofdstuk-2",
    "href": "02_numeriek.html#overzicht-van-functies-en-argumenten-uit-hoofdstuk-2",
    "title": "Eén numerieke variabele visualiseren",
    "section": "3 Overzicht van functies en argumenten uit hoofdstuk 2",
    "text": "3 Overzicht van functies en argumenten uit hoofdstuk 2\nDe onderstaande functies en argumenten zijn in dit hoofdstuk aan bod gekomen:\n\nfunctie geom_histogram() met aesthetic x en de argumenten bins, binwidth, fill, color en alpha\n\nfunctie geom_boxplot() met aesthetics x of y en de argumenten outliers, outlier.fill, fill, color en alpha\nfunctie geom_jitter() met aesthetics x en y en de argumenten height, size, shape en alpha\n\nfuncties scale_x_continuous() en scale_x_continuous() met de argumenten breaks en position.\n\nfunctie labs() met de argumenten title, subtitle, x en y\n\nLet op! De meeste functies beschikken over veel meer argumenten dan deze die in dit hoofdstuk aan bod zijn gekomen. Om hier een overzicht van te krijgen, kan je de help-functie gebruiken. Ook de specifieke aesthetics die je kan toevoegen aan elke *geom*-functie zijn uitgebreider dan je hier terug vindt. Daarover meer in de volgende hoofdstukken.",
    "crumbs": [
      "Visualiseren van één numerieke variabele"
    ]
  },
  {
    "objectID": "04_meerdere_variabelen.html",
    "href": "04_meerdere_variabelen.html",
    "title": "Datavisualisatie met ggplot2",
    "section": "",
    "text": "Dit hoofdstuk focust op het plotten van meer dan één variabele. Eerst spelen we een beetje vals en bekijken we hoe je een tweede variabele kan toevoegen aan een boxplot en aan een staafdiagram. Vervolgens focussen we ons op twee grafiektypes die meer dan één variabele als input hebben: een puntenwolk en een lijngrafiek.",
    "crumbs": [
      "Meer dan één variabele visualiseren"
    ]
  },
  {
    "objectID": "04_meerdere_variabelen.html#boxplot-van-meerdere-groepen",
    "href": "04_meerdere_variabelen.html#boxplot-van-meerdere-groepen",
    "title": "Datavisualisatie met ggplot2",
    "section": "1 Boxplot van meerdere groepen",
    "text": "1 Boxplot van meerdere groepen\nIn hoofdstuk 2 maakte je een boxplot van de variabele flipper_length_mm. Stel dat je de verdeling van deze variabele wil plotten naar pinguïnsoort (species). Je zou dit kunnen doen via een boxplot per pinguïnsoort. Er zijn twee manieren om dit aan te pakken: met facets of door een extra scale toe te voegen.\n\n1.1 Boxplot met facet_wrap\nDe code hieronder zou je bekend moeten voorkomen. Je kwam deze reeds tegen in hoofdstuk 2 toen we een boxplot maakte van de variabele flipper_length_mm en daar ook de datapunten zelf aan toevoegden. De enige code die is toegevoegd, vind je op lijn 22. De functie facet_wrap() gebruik je om small multiples te creëren (ook facets genoemd). De facets worden gecreëerd op basis van de variabele die na ~ komt (in dit geval dus species). Via het argument nrow geef je over hoeveel rijen de facets moeten worden geplot.\nLaat de code hieronder lopen en bekijk het resultaat. Verander het getal achter nrow vervolgens naar 1 en vergelijk met het vorige resultaat. Merk ook op dat de boxplot van de Adélie-pinguïns nu wel twee outliers bevat (rood ingekleurd). Doordat de datapunten geplot zijn met wat ruis (via geom_jitter()) lijkt het alsof er nog andere datapunten ook outliers zijn. Dit is verwarrend voor de kijker. Door het argument outliers = TRUE in de functie geom_boxplot() op FALSE te zetten vermijd je dat de outliers worden ingekleurd.\n\n\n\n\n\n\n\n\n1.2 Boxplot inkleuren volgens species\nEen tweede manier om de verdeling van flipper_length_mm volgens pinguïnsoort zichtbaar te maken, is gebruik maken van kleur. Dit bereik je door aan de functie ggplot() een y-variabele (species) en fill- en color-aesthetic toe te voegen. In de functie geom_jitter() is de oorspronkelijke y-aesthetic (y = 0) weggehaald. In hoofdstuk 3 leerde je zelf bepalen welke kleuren ggplot2 moet gebruiken bij het inkleuren naar pinguïnsoort (zie ?@sec-dotplot-kleur). Voeg deze code hier toe en kies zelf drie kleuren.\n\n\n\n\n\n\n\n\n1.3 Boxplot inkleuren met ingebouwde kleurpaletten\nTot nu toe bepaalde je zelf de kleuren voor het inkleuren volgens pinguïnsoort. Er zitten echter verschillende kleurpaletten ingebouwd in ggplot2. In dit OLP focussen we ons op de kleurpaletten van RColorBrewer.\n\n\n\n\n\n\nKleurpaletten uit RColorBrewer\n\n\n\nRColorBrewer is ontwikkeld door Cynthia Brewer (een professor geografie) en biedt een uitgebreide verzameling van de drie types kleurpaletten die zijn gebaseerd op het ColorBrewer-project. Dit project werd opgezet om kleurenpaletten te ontwikkelen die effectief zijn binnen cartografie, maar de paletten worden ondertussen gebruikt in de bredere context van datavisualisatie. De kleurpaletten zijn speciaal ontworpen om de leesbaarheid en interpretatie ervan te verbeteren en houdt ook rekening met kleurenblindheid. De verschillende kleurschalen zijn ondertussen dus ook geïmplementeerd in ggplot2. Daarbij wordt een onderscheid gemaakt tussen drie soorten kleurpaletten:\n\nKwalitatieve kleurschaal Een kwalitatieve kleurschaal bestaat uit een reeks van kleuren die niet in een specifieke volgorde zijn te rangschikken. Dit type kleurschaal wordt gebruikt om nominale variabelen weer te geven (waarbij de categorieën dus geen inherente volgorde hebben). Voorbeelden van variabelen die je kan visualiseren a.d.h.v. een kwalitatieve kleurschaal zijn het type leeromgeving (online, hybride, face-to-face) of gender.\n\nSequentiële kleurschaal Een sequentiële kleurschaal bestaat uit een reeks kleuren die overgaan van de ene tint naar de andere, meestal van lichtere naar donkerdere schakeringen of omgekeerd. Sequentiële kleurschalen worden gebruikt om ordinale of numerieke variabelen weer te geven. Voorbeelden van variabelen die a.d.h.v. een sequentiële kleurschaal kunnen worden gevisualiseerd zijn tevredenheidsscore (gemeten o.b.v. een Likert-schaal) of lichaamsgewicht. In een sequentiële kleurschaal moet de kleurkeuze en de richting van de ordening (van licht naar donker of van donker naar licht) de aard van de weer te geven informatie reflecteren (bv. meer tevreden = donkerdere tint van blauw).\n\nDivergerende kleurschaal Een divergerende kleurschaal bestaat uit twee sequentiële kleurschalen die samenkomen bij een centraal middelpunt. Divergerende kleurschalen zijn nuttig voor het visualiseren van gegevens die een natuurlijk middelpunt of kritieke waarde hebben, zoals afwijkingen t.o.v. het gemiddelde of temperatuur.\n\n\n\n\nOm een kleurenpalet van RColorBrewer te gebruiken, hanteer je de functie scale_fill_brewer() en/of scale_color_brewer(). Tussen de haakjes voeg je het type schaal toe (kwalitatief \"qual\", sequentieel \"seq\" of divergerend \"div\") en de naam van het palet dat je wenst te gebruiken. Bijvoorbeeld, scale_fill_brewer(type = \"qual\", palette = \"Set2). Hieronder vind je de verschillende paletten beschikbaar in RColorBrewer per type kleurschaal (en de namen van de kleurenpaletten). Je vindt meteen ook de code terug om deze paletten te bekijken in RStudio. Door aan de functie display.brewer.all() nog het argument colorblindFriendly toe te voegen, krijg je alleen paletten te zien die geschikt zijn voor mensen met kleurenblindheid.\n\nRColorBrewer::display.brewer.all()\n\n\n\n\n\n\n\n\nVoeg nu zelf een gepast kleurenpalet uit RColorBrewer toe aan de plot. (Je wil zowel de opvulling als de omtrek van de boxplots inkleuren!) Denk daarbij goed na over het type variabele dat species is. Dit bepaalt immers welk type kleurenpalet je dient te gebruiken.",
    "crumbs": [
      "Meer dan één variabele visualiseren"
    ]
  },
  {
    "objectID": "04_meerdere_variabelen.html#staafdiagram-met-meerdere-categorische-variabelen",
    "href": "04_meerdere_variabelen.html#staafdiagram-met-meerdere-categorische-variabelen",
    "title": "Datavisualisatie met ggplot2",
    "section": "2 Staafdiagram met meerdere categorische variabelen",
    "text": "2 Staafdiagram met meerdere categorische variabelen\nHoofdstuk 3 focuste op het maken van een staafdiagram van het aantal pinguïns per soort. We hielden daarbij geen rekening met het geslacht van de pinguïns. Hier gaan we dat wel doen door een tweede categorische variabele (sex) toe te voegen aan het staafdiagram.\n\n\n\n\n\n\n\n\n\n\n2.1 Staafdiagram met geom_bar()\nOm een staafdiagram te maken van de variabelen sex en species, gebruik je de functie geom_bar(). Hierbij dien je twee aesthetics te specificeren: een x-variabele (sex) en een fill-variabele (species). Verder geef je via het argument position aan hoe de staven (die beide geslachten weergeven) gepositioneerd moeten worden. Je kan daarbij kiezen uit position = position_stack() (staven die geslacht weergeven staan op elkaar) of position = position_stack() (staven staan naast elkaar). Verander in de code hieronder de waarde voor het argument position en kijk wat er gebeurt.\n\n\n\n\n\n\n\n\n2.2 Staafdiagram met relatieve frequenties\nTot nu toe bevatte het staafdiagram telkens de absolute aantallen. Als je een staafdiagram met relatieve frequenties wil, dan kies je voor position = position_fill()`. Probeer dit hieronder uit!\nJe merkte vermoedelijk al op dat het geslacht van enkele pinguïns niet werd geregistreerd. Deze worden door geom_bar() nu als een derde categorie beschouwd. Er zijn verschillende manieren om dit te voorkomen. De simpelste manier is toegevoegd aan de code hieronder en maakt gebruik van de functie filter() uit het package dplyr.\n\n\n\n\n\n\n\n\n2.3 De staven labelen\nWe werken verder met het staafdiagram met de absolute frequenties. Je kan de aantallen die de staven weergeven ook labelen door geom_text() toe te voegen aan de code. Je dient daarbij aan te geven welk label (het juiste aantal) boven elke staaf geplaatst moet worden. Dat doe je door aes(label = after_stat(count) toe te voegen aan geom_text(). Verder dien je ook in geom_text() expliciet de positie van de staven aan te geven (position = position_dodge(width = 0.90)) Het argument width = 0.9 wordt gebruikt om de plaats van de labels te bepalen. Speel met de waarde van dit argument en kijk wat er gebeurt.\n\n\n\n\n\n\nKan je de code aanpassen zodanig dat de staven op elkaar geplaatst worden? Je zal daarbij ook met de waarde van het argument vjust moeten spelen om de labels op een ‘goede’ positie te krijgen.\n\n\n\n\n\n\n\n\n2.4 Inkleuren volgens geslacht\nIn een laatste stap voeg je een gepast kleurenpalet uit RColorBrewer toe aan de plot om de variabele sex in te kleuren.",
    "crumbs": [
      "Meer dan één variabele visualiseren"
    ]
  },
  {
    "objectID": "04_meerdere_variabelen.html#puntenwolk",
    "href": "04_meerdere_variabelen.html#puntenwolk",
    "title": "Datavisualisatie met ggplot2",
    "section": "3 Puntenwolk",
    "text": "3 Puntenwolk\nTot nu toe hebben we telkens maar een x- of een y-variabele meegegeven als aesthetic. Daar komt nu verandering in bij het maken van een puntenwolk die het verband tussen lichaamsgewicht (body_mass_g) en vleugellengte (flipper_length_mm) weergeeft.\n\n\n\n\n\n\n\n\n\n\n3.1 Puntenwolk met geom_point()\nOm een puntenwolk te maken, gebruik je de functie geom_point(). Je dient daarbij aan te geven welke variabele op de x-as dient te komen en welke variabele op de y-as.\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Zorg dat de packages tidyverse en palmerpenguins geladen zijn. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n  data = penguins,\n  aes(\n    x = body_mass_g,\n    y = flipper_length_mm\n    )\n  ) +\n  geom_point(\n    shape = 16,\n    size = 1,\n    color = \"#AAAA17\",\n    alpha = 0.75\n  ) +\n  labs(\n    title = \"Puntenwolk van lichaamsgewicht en vleugellengte\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\",\n    x = \"Lichaamsgewicht (in g)\",\n    y = \"Vleugellengte (in mm)\"\n  ) + \n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n\n\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\nMerk op dat in geom_point() de kleur van de datapunten wordt gespecificeerd met behulp van een hexadecimal (HEX). Dit is een andere manier om kleuren te specificeren. Via deze link vind je informatie terug over de verschillende manieren waarop je in R kleuren kan benoemen.\n\n\n3.2 Een trendlijn toevoegen met geom_smooth()\nVaak wil je het verband tussen body_mass_g en flipper_length_mm ook weergeven met een trendlijn. Je kan eenvoudig een trendlijn aan je puntenwolk toevoegen met behulp van de functie geom_smooth(). Deze functie vraagt als input om een x- en een y-variabele. In de code hieronder worden deze echter niet meegegeven. geom_smooth() ‘erft’ dan de x- en y-variabelen die in de functie ggplot() zijn meegegeven. Verder vind je vier argumenten terug:\n\nmethod = \"lm\": dit argument geeft aan welke methode geom_smooth() moet gebruiken bij het plotten van de trendlijn (\"lm\" staat voor een lineaire trendlijn)\n\nse: bepaalt of de onzekerheid rond de trendlijn wordt weergegeven (se = TRUE) of niet (se = FALSE).\n\nlinewidth: bepaalt de dikte van de lijn\n\ncolor: bepaalt de kleur van de lijn\n\nSpeel in de code hieronder met de argumenten se, linewidth en color en bekijk wat het effect is.\n\n\n\n\n\n\n\n\n3.3 Vorm van datapunten volgens geslacht\nStel dat je ook wil visualiseren wat het geslacht van de pinguïns is. Je zou daarvoor kleur kunnen toevoegen aan de puntenwolk, maar er zijn ook andere mogelijkheden. Eén daarvan is de vorm van de punten laten afhangen van de variabele sex. Hiertoe is er in de code hieronder een extra aesthetic toegevoegd aan de geom_point()-functie: shape = sex. Verder is ook de functie scale_shape_manual() toegevoegd met het argument values = c(15, 16). Op die manier kan je zelf aangeven welke vormen moeten worden gebruikt om de mannetjes- en vrouwtjespinguïns weer te geven.\n\nCodePlot\n\n\n\npenguins %&gt;%\n  filter(!is.na(sex)) %&gt;%\n  ggplot(\n  aes(\n    x = body_mass_g,\n    y = flipper_length_mm\n    )\n  ) +\n  geom_point(\n    aes(shape = sex),\n    size = 1,\n    color = \"#AAAA17\",\n    alpha = 0.75\n  ) +\n  geom_smooth(\n    method = \"lm\",\n    se = FALSE,\n    linewidth = 0.5,\n    color = \"black\"\n  ) +\n  scale_shape_manual(\n    values = c(15, 16)\n    ) +\n  labs(\n    title = \"Puntenwolk van lichaamsgewicht en vleugellengte\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\",\n    x = \"Lichaamsgewicht (in g)\",\n    y = \"Vleugellengte (in mm)\"\n  ) + \n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\nHad je ook een tweede trendlijn verwacht? Door de aesthetic shape = sex toe te voegen aan geom_point() wordt deze alleen toegepast op deze geom. Om ook een trendlijn te plotten per geslacht zijn er twee opties:\n\nshape = sex ook als aesthetic toevoegen aan geom_smooth()\n\nshape = sex toevoegen als aesthetic aan ggplot() zodat het wordt toegepast op alle geoms die volgen.\n\nKies één van beide opties en pas de code hieronder aan. Lukt het je om een trendlijn per geslacht te plotten?\n\n\n\n\n\n\n\n\n3.4 Kleur toevoegen aan de scatterplot\nDe vorm van de punten is nu aangepast aan het geslacht van de pinguïns. Zorg er nu ook voor dat de kleur van de datapunten en de trendlijnen afhangen van de variabele sex. Voeg daarvoor hieronder de nodige code toe. Gebruik meteen ook een gepast RColorBrewer-palet.\n\n\n\n\n\n\n\n\n3.5 Puntenwolk met facet_wrap()\nOm de puntenwolk ‘af’ te maken, voeg je aan je code nog de functie facet_wrap(~island) toe. Dit zorgt ervoor dat er drie puntenwolken worden geplot (één per eiland waar er pinguïns wonen). Als je de code hieronder laat lopen, zal je merken dat de breaks op de x-as en y-assen in alle facets precies hetzelfde zijn. Je kan dit aanpassen door het argument scales = \"free\" toe te voegen aan de functie facet_wrap(). Dit argument kan ook de waarde \"free_x\" of \"free_y\" aannemen. Probeer de verschillende waardes uit en kijk wat hun effect is.\n\n\n\n\n\n\n\n\n3.6 Puntenwolk van gestandaardiseerde variabelen\nStel dat je dezelfde puntenwolk wil maken, maar nu met gestandaardiseerde variabelen op de x- en y-as. Dit kan heel eenvoudig door gebruik te maken van de functie mutate() uit het package dplyr. Tussen de haakjes van de functie geef je aan welke variabele(n) je wenst aan te maken. Hier zijn dat de variabelen body_mass_Z en flipper_length_Z. Deze variabelen zijn gestandaardiseerd door gebruik te maken van de functie scale (body_mass_Z) en door zelf de nodige berekeningen uit te voeren (flipper_length_Z). Het enige wat je verder dient te doen, is de namen van de x- en y- variabele in de aesthetics van de ggplot()-functie aanpassen (en de labels van de x- en y-as). Doe dit en laat de code lopen!",
    "crumbs": [
      "Meer dan één variabele visualiseren"
    ]
  },
  {
    "objectID": "04_meerdere_variabelen.html#lijngrafiek",
    "href": "04_meerdere_variabelen.html#lijngrafiek",
    "title": "Datavisualisatie met ggplot2",
    "section": "4 Lijngrafiek",
    "text": "4 Lijngrafiek\nIn hoofdstuk 3 maakten we staafdiagrammen van het aantal pinguïns per soort. Hier gaan we na hoeveel pinguïns per soort er werden geteld in de drie opeenvolgende jaren waarin de observaties plaatsvonden. Om dit weer te geven, maken we gebruik van een lijngrafiek\n\n\n\n\n\n\n\n\n\n\n4.1 Lijngrafiek met geom_line()\nVooraleer je een lijngrafiek kan maken van pinguïnsoort naar jaar dien je een nieuwe dataset aan te maken die de frequenties per pinguïnsoort per jaar bevat. Hiervoor kan je gebruik maken van een combinatie van de functies group_by() en count(). Laat de code hieronder lopen en bekijk het resultaat.\n\n\n\n\n\n\nJe creëerde een dataset (een tibble in tidyverse-taal) gemaakt die je kan gebruiken om een lijngrafiek te maken. Daarvoor maak je gebruik van het geom geom_line() waarbij je year als x-variabele meegeeft en n als y-variabele. Het derde aesthetic dat je aan ggplot() toevoegt is group = species. Test hieronder uit wat er gebeurt met de lijngrafiek als je group weglaat.\n\n\n\n\n\n\n\n\n4.2 Basisargumenten geom_line()\nJe kan verschillende argumenten toevoegen aan de functie geom_line(). De betekenis van color (kleur van de lijn) en van alpha (transparantie van de lijn) ken je al. Met de argumenten linewidth en linetype pas je respectievelijk de dikte en de stijl van de lijn aan. Qua lijntype kan je kiezen uit de volgende waarden:\n- “solid” of 1\n- “dashed” of 2\n- “dotted” of 3\n- “dotdash” of 4.\n- “longdash” of 5\n- “twodash” of 6\n- “blank” of 0\nSpeel in de code hieronder met de argumenten linewidth en linetype en bekijk wat het effect is.\n\n\n\n\n\n\n\n\n4.3 Breaks op x- en y-as aanpassen\nDe breaks op de x- en de y-as dienen nog aangepast te worden. Voeg daarvoor in de code hieronder de nodige argumenten toe aan de functies scale_x_continuous() en scale_y_continuous(). Hieronder wordt per as aangegeven voor welke zaken je argumenten dient toe te voegen.\nZorg ervoor dat de x-as:\n- alleen de breaks 2007, 2008 en 2009 bevat,\n- van 2007 t.e.m. 2009 loopt,\n- bovenaan wordt weergegeven en - geen titel (naam) meer heeft.\nZorg ervoor dat de y-as:\n- de volgende breaks bevat: 10, 20, 30, 40, 50, 52,\n- van 0 t.e.m. 55 loopt,\n- geen titel (naam) meer heeft.\n\n\n\n\n\n\nMerk op dat er nog twee argumenten zijn toegevoegd aan de functie theme(): axis.text.x = element_text(size =  8, color = \"grey50\") en axis.text.y = element_text(size =  6, color = \"grey80\"). Deze argumenten definiëren de kleur en grootte van de labels op de x- en y-as.\n\n\n4.4 Lijntype en lijnkleur volgens pinguïnsoort\nTot nu toe is elke lijn van hetzelfde type en dezelfde kleur. Door aan ggplot() het aesthetic linetype = species toe te voegen, wordt het lijntype afhankelijk van de pinguïnsoort. Als je zelf wil bepalen welke lijntypes hiervoor worden gebruikt, dan voeg je ook scale_linetype_manual(values = c(1, 2, 3)) toe. Voeg deze zaken toe aan de code hieronder.\nZorg er ook voor dat de kleur van de lijnen ook afhangt van de variabele species. Voeg daarvoor hieronder de nodige code toe. Gebruik meteen ook een gepast RColorBrewer-palet.\n\n\n\n\n\n\nAan de theme()-functie zijn bijkomende argumenten toegevoegd om alle ’minor’gridlijnen te verwijderen (panel.grid.minor = element_blank()), de ’major’gridlijnen die vertrekken vanuit de x-as (panel.grid.major.x = element_blank()) en de legende naar onderen te verplaatsen (legend.position = \"bottom\").\n\n\n4.5 Lijnen zelf labellen\nAls je de legende uit een plot kan weglaten, is dat meestal een goed idee. Daardoor moet de kijker geen informatie vanop twee plaatsen (de legende en de lijn)combineren. Een handig alternatief voor een legende is in dit geval het rechtstreeks labelen van de verschillende lijnen. Dit kan je eenvoudig doen met behulp van het package geomtextpath.\nHet pakket geomtextpath bevat voor enkele geoms een aangepaste versie die toelaat om lijnen (functie geom_textline()) of trendlijnen (functie geom_textsmooth()) te labelen. Het gebruik van deze functies is hetzelfde als dat van de originele geoms, met als enige toevoeging het aesthetic label. In de code hieronder is pinguïnsoort (species) als label meegegeven. Doordat je in de ggplot()-functie hebt aangegeven dat de lijnen moeten worden ingekleurd volgens species wordt dit aan geom_textline() doorgegeven. De tekst in geom_textline() wordt dus ook volgens pinguïnsoort ingekleurd. (Dit geldt ook voor het lijntype.). De argumenten size=2, linewidth = 0.2 en hjust = 0.2 bepalen respectievelijk de grootte van de letters, de dikte van de lijn en de locatie van de labels op de lijnen.\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Zorg dat de packages tidyverse, palmerpenguins en geomtextpath geladen zijn. (Vergeet geomtextpath niet eerst te installeren.) Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nlibrary(geomtextpath)\npenguins %&gt;%\n  filter(!is.na(sex)) %&gt;%\n  group_by(year, species) %&gt;%\n  count() %&gt;%\n  ggplot(\n    aes(\n      x = year,\n      y = n,\n      group = species,\n      color = species,\n      linetype = species\n      )\n  ) +\n  geom_textline(\n    aes(label = species),\n    size = 2,\n    linewidth = 0.2,\n    hjust = 0.2\n  ) +\n  labs(\n    title = \"Lijngrafiek van het aantal pinguins per soort in 2007, 2008 en 2009\",\n    subtitle = \"Gebaseerd op de Palmer Penguin data\",\n  ) + \n  scale_x_continuous(\n    breaks = c(2007, 2008, 2009),\n    limits = c(2007, 2009),\n    name = NULL,\n    position = \"top\"\n  ) +\n  scale_y_continuous(\n    breaks = c(seq(0, 50, 10), 52),\n    limits = c(0, 55),\n    name = NULL\n  )+\n  scale_fill_brewer(\n    type = \"qual\", palette = \"Set1\"\n    ) +\n  coord_cartesian(expand = FALSE) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\"),\n    plot.margin = margin(0,5,0,0, unit = \"mm\"),\n    axis.text.x = element_text(size =  8, color = \"grey50\"),\n    axis.text.y = element_text(size =  6, color = \"grey80\"),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank(),\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDe legende is verwijderd door in theme() het argument legend.position als waarde \"none\" mee te geven. De functie coord_cartesian(expand = FALSE) zorgt ervoor dat de overtollige ‘plaats’ aan de linker- en rechterkant van de grafiek wordt verwijderd.",
    "crumbs": [
      "Meer dan één variabele visualiseren"
    ]
  },
  {
    "objectID": "04_meerdere_variabelen.html#een-universum-aan-visualisatiemogelijkheden",
    "href": "04_meerdere_variabelen.html#een-universum-aan-visualisatiemogelijkheden",
    "title": "Datavisualisatie met ggplot2",
    "section": "5 Een univeRsum aan visualisatiemogelijkheden",
    "text": "5 Een univeRsum aan visualisatiemogelijkheden\nIn dit OLP komen slechts een beperkt aantal grafiektypes aan bod. Via ggplot2 kan je echter (bijna) elke denkbare grafiek maken. Handige vertrekpunten om verder aan de slag te gaan met ggplot2 zijn de cheat sheet ‘datavisualisatie met ggplot2’ en de website from Data to Viz. Deze website bevat niet alleen een handige tool om gepaste grafieken te kiezen voor het type data te je hebt, het geeft er ook de nodige R-code bij! Tenslotte is het ook goed om mee te geven dat er al een hele hoop packages zijn ontwikkeld die verderbouwen op ggplot2. Een overzicht van al deze extensies vind je op deze website.",
    "crumbs": [
      "Meer dan één variabele visualiseren"
    ]
  },
  {
    "objectID": "04_meerdere_variabelen.html#overzicht-van-functies-en-argumenten-uit-hoofdstuk-4",
    "href": "04_meerdere_variabelen.html#overzicht-van-functies-en-argumenten-uit-hoofdstuk-4",
    "title": "Datavisualisatie met ggplot2",
    "section": "6 Overzicht van functies en argumenten uit hoofdstuk 4",
    "text": "6 Overzicht van functies en argumenten uit hoofdstuk 4\nDe onderstaande functies en argumenten zijn in dit hoofdstuk aan bod gekomen:\n\nfunctie geom_boxplot() met aesthetics x of y en de argumenten outliers, outlier.fill, fill, color en alpha\nfunctie geom_jitter() met aesthetics x en y en de argumenten height, size, shape en alpha\n\nfunctie geom_bar() met de argumenten position\n\nfunctie geom_text() met de argumenten label, position, vjust, stat en color\n\nfunctie geom_line() met de argumenten linewidth, linetype en color\n\nfunctie geom_textline() met de argumenten label, size, linewidth en color\nfuncties scale_color_brewer() en scale_fill_brewer() met de argumenten type en palette\n\nfunctie scale_shape_manual() met het argument values\n\nfunctie scale_linetype_manual() met het argument values\n\nfunctie facet_wrap() met de argumenten ~variable en nrow\n\nfuncties position_dodge() (met argument width), position_stack() en position_fill()\n\nfunctie filter()\n\nfunctie mutate()\n\nLet op! De meeste functies beschikken over veel meer argumenten dan deze die in dit hoofdstuk aan bod zijn gekomen. Om hier een overzicht van te krijgen, kan je de help-functie gebruiken. Ook de specifieke aesthetics die je kan toevoegen aan elke *geom*-functie zijn uitgebreider dan je hier terug vindt. Daarover meer in de volgende hoofdstukken.",
    "crumbs": [
      "Meer dan één variabele visualiseren"
    ]
  },
  {
    "objectID": "03_categorisch.html",
    "href": "03_categorisch.html",
    "title": "Eén categorische variabele visualiseren",
    "section": "",
    "text": "Er bestaan verschillende manieren om de verdeling van een categorische variabele voor te stellen. Enkele voorbeelden daarvan zijn een staafdiagram (?@sec-staafgram), een dotplot (Sectie 2) of een lollipop plot (Sectie 3). In dit hoofdstuk focussen we ons op hoe je dit type grafieken kan maken met ggplot2. We maken opnieuw gebruik van de pinguïndata en focussen ons op het visualiseren van de verdeling van de categorische variabele species. Op het einde van dit hoofdstuk vind je een overzicht van de verschillende functies en hun argumenten die je in dit hoofdstuk leerde (?@sec-overzichtcat).",
    "crumbs": [
      "Visualiseren van één categorische variabele"
    ]
  },
  {
    "objectID": "03_categorisch.html#staafdiagram",
    "href": "03_categorisch.html#staafdiagram",
    "title": "Eén categorische variabele visualiseren",
    "section": "1 Staafdiagram",
    "text": "1 Staafdiagram\nEen eerste mogelijkheid om de verdeling van de variabele specieste visualiseren is gebruik maken van een staafdiagram. Hieronder vind je een voorbeeld van een staafdiagram die je na het doorlopen van dit luikje zelf zal kunnen maken.\n\n\nWarning: The dot-dot notation (`..count..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(count)` instead.\n\n\n\n\n\n\n\n\n\n\n1.1 Staafdiagram met geom_bar() of geom_col()\nOm een staafdiagram te maken kan je in ggplot gebruik maken van twee verschillende geoms: geom_bar() of geom_col(). Hieronder vind je dezelfde staafdiagram gecreërd met geom_bar() (links) of geom_col() (rechts). Vergelijk de code en probeer beiden uit. Wat is het verschil tussen beide functies?\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(\n  data = penguins,\n  aes(\n    x = species\n    )\n  ) +\n  geom_bar() +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\ncount_data &lt;- \n  penguins %&gt;%\n  ## Tel pinguins per soort (species)\n  ## Schrijf deze weg in de kolom `count`\n  count(species, name = \"count\")\n\nggplot(\n  data = count_data,\n  aes(\n    x = species,\n    y = count\n    )\n  ) +\n  geom_col() +\n  theme_minimal()\n\n\n\nHet grote verschil tussen beide functies is dat geom_bar() op de achtergrond het telwerk voor jou uitvoert, terwijl geom_col() ervanuit gaat dat jij het telwerk al deed. Om geom_col() te kunnen gebruiken, dien je dus een dataset aan te maken die de frequenties per pinguïnsoort bevat. Dit merk je ook aan het verschil in aesthetics. In geom_bar() wordt alleen een x-variabele gespecificeerd (de categorische variabele species). De functie geom_col() vraagt zowel om een x-variabele (de categorische variabele species) als een y-variabele (de numerieke variabele die de aantallen bevat count). Vanaf hier maken we gebruik van de functie geom_bar(). De zaken die je daarbij leert, kan je steeds ook toepassen bij het gebruik van geom_col(). Als de toepassing voor geom_col() toch anders is dan tonen we deze ook.\n\n\n1.2 Basisargumenten geom_bar()\nIn het staafdiagram hieronder zijn er drie argumenten toegevoegd aan de functie geom_bar():\n\nwidth: bepaalt de breedte van de staven (default = 1)\n\nfill: opvulkleur van de staven\n\ncolor: kleur van de lijn rondom de staven\n\nLaat de code hieronder lopen en bekijk het staafdiagram. Speel vervolgens met de waarden van de argumenten width, fill en color en kijk wat er gebeurt.\n\n\n\n\n\n\n\n\n1.3 Staven ordenen\nAls je de functie geom_bar() gebruikt, kan je de staven van groot naar klein ordenen met de functie fct_infreq(). Dit is een functie uit het package forcats, een ander package uit de tidyverse. (Als je in het begin van je R-sessie het package tidyverse laat, staan dus ook de functies uit het package forcats klaar voor gebruik.) Om deze functie te kunnen gebruiken, dient de variabele species als factor in de dataset te zitten (wat het geval is). De functie zorgt ervoor dat de levels geplot worden volgens de frequentie waarmee ze voorkomen.\nAls je de code hieronder laat lopen, zal je vaststellen dat de meest voorkomende pinguïnsoort Adélie is, gevolgd door Gentoo en Chinstrap. Wil je de staven van klein naar groot ordenen? Voeg de functie fct_rev() aan de code hieronder toe (fct_rev(fct_infreq(species))) en run de code opnieuw.\n\n\n\n\n\n\nGebruik je de functie geom_col() om een staafdiagram te maken? Dan hanteer je de functie reorder() zoals in het voorbeeld hieronder. De staven worden nu van klein naar groot georderd. Wil je de volgorde omdraaien? Plaats dan een - voor count (x = reorder(species, -count)). Probeer beide mogelijkheden uit.\n\n\n\n\n\n\n\n\n1.4 Titel, subtitel en titel van de assen toevoegen\nVia de functie labs() kan je de labels van zowel de titel (title), subtitel (subtitle), als de namen van de x- en y-as aanpassen. Bedenk gepaste titels voor de staafdiagram over het aantal pinguïns per soort en vul de code hieronder aan.\n\n\n\n\n\n\nAan de theme()-functie zijn twee argumenten toegevoegd om de lay-out van de tekst in de titel (plot.title = element_text(face = \"bold\")) en de subtitel (plot.subtitle = element_text(face = \"italic\")) aan te passen.\n\n\n1.5 De staven labelen\nTot nu toe moest de kijker de hoogte van de staven zelf aflezen op de y-as. Soms is het echter handig om boven elke staaf het aantal (pinguïns) te zetten. Dit kan je doen door een tweede geom te gebruiken: geom_text(). Je dient daarbij aan te geven welk label boven elke staaf geplaatst moet worden. Dat doe je door aes(label = after_stat(count)) toe te voegen aan geom_text(). Het stukje count uit de code verwijst naar het getelde aantal pinguïns dat ggplot2 op de achtergrond heeft berekend. Je dient geom_text() ook mee te geven welke variabele er op de x-as moet komen. In de code hieronder is er echter geen x aesthetic meegegeven. In dat geval ‘erft’ geom_text() de aesthetics van de ggplot()-functie.\nDe betekenis van de drie andere argumenten die zijn toegevoegd aan geom_text() wordt hieronder uitgelegd:\n\nstat: geeft aan wat er precies boven de staaf geplaatst moet worden\n\nvjust: de verticale positie van het label (0 = precies op de bovenkant van de staaf, &gt; 0 boven de staaf, &lt; 0 = onder de bovenkant van de staaf)\n\nsize: grootte van de letters\n\ncolor: kleur van de letters\n\nPas de waarden van de verschillende argumenten in de code hieronder aan en kijk wat er gebeurt.\n\n\n\n\n\n\nJe hebt misschien opgemerkt dat er nog een beetje code is toegevoegd aan de theme()-functie. Met deze code zijn alle gridlijnen verwijderd (panel.grid = element_blank()) en is ook de tekst op de y-as verwijderd (axis.text.y = element_blank()).\nAls je geom_col() gebruikt, dan gebruik je andere code voor het toevoegen van de labels met getallen. Deze code vind je terug in het luikje rond het toevoegen van labels met getallen aan een dotplot (zie Paragraaf 2.4).\n\n\n1.6 De assen van plaats veranderen\nAls de waarden van de variabele op de x-as heel lang zijn, is het handig om de x- en y-as van plaats te veranderen. (Denk bijvoorbeeld aan de labels van een Likert schaal: “Helemaal niet akkoord”.) Door de assen van plaats te veranderen blijft de leesbaarheid van die waarden optimaal. Om de assen van plaats te veranderen, bestaat er een handige functie in ggplot2: coord_flip().\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Zorg dat de packages tidyverse en palmerpenguins geladen zijn. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n  data = penguins,\n  aes(\n    x = fct_infreq(species)\n    )\n  ) +\n  geom_bar(\n    width = .5,\n    fill = \"grey\",\n    color = \"black\"\n  ) +\n  geom_text(\n    aes(label = ..count..),\n    stat = \"count\",\n    hjust = -0.2, ## vjust wordt hjust\n    size = 3,\n    color = \"black\"\n    ) +\n  labs(\n    x = \"Pinguïnsoort\",\n    y = \"Aantal\",\n    title = \"Staafdiagram van aantal pinguïns per soort\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\"\n  ) +\n  coord_flip() +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\"),\n    panel.grid = element_blank(),\n    axis.text.y = element_blank()\n  )",
    "crumbs": [
      "Visualiseren van één categorische variabele"
    ]
  },
  {
    "objectID": "03_categorisch.html#dotplot",
    "href": "03_categorisch.html#dotplot",
    "title": "Eén categorische variabele visualiseren",
    "section": "2 Dotplot",
    "text": "2 Dotplot\nEen andere mogelijkheid om de verdeling van het aantal pinguïns per soort te visualiseren is een dotplot. Hieronder vind je een voorbeeld van een dotplot.\n\n\n\n\n\n\n\n\n\nIn ggplot2 maak je een dotplot met behulp van geom_point().\n\n2.1 Dotplot met geom_point()\nVooraleer je de dotplot kan maken, dien je eerst een dataset aan te maken die de frequenties per pinguïnsoort bevat (net zoals bij het maken van een staafdiagram met geom_col()). Deze dataset kan je vervolgens gebruiken om de dotplot te maken. Daarbij plaats je pinguïnsoort (species) op de x-as en het aantal pinguïns (count) op de y-as. De rest van de code zou je bekend moeten voorkomen. Deze is overgenomen van de code om een staafdiagram te maken.\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\ncount_data &lt;-\n  penguins %&gt;%\n  count(species, name = \"count\")\n\nggplot(\n  data = count_data,\n  aes(\n    x = species,\n    y = count\n    )\n  ) +\n  geom_point(\n  ) +\n  labs(\n    x = \"Pinguïnsoort\",\n    y = \"Aantal\",\n    title = \"Dotplot van aantal pinguïns per soort\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.2 Basisargumenten geom_point()\nIn de dotplot hieronder zijn er vier argumenten toegevoegd aan de functie geom_point():\n\nshape: bepaalt de vorm van de punten en wordt aangegeven met een getal. Hier vind je een overzicht van de beschikbare vormen in R. Afhankelijk van de vorm is het mogelijk om een kleur (color) en/of vulling (fill) te bepalen.\n\nsize: bepaalt de grootte van de punten (default = 0.5)\n\ncolor: bepaalt de kleur van de lijn rond de punten (voor vormen 1 t.e.m. 14 en 21 t.e.m. 25)\n\nfill: bepaalt de opvulkleur van de punten (voor vormen 15 t.e.m. 25)\n\nLaat de code hieronder lopen en bekijk de dotplot. Speel vervolgens met de waarden van de verschillende argumenten en kijk wat er gebeurt.\n\n\n\n\n\n\n\n\n2.3 Dots ordenen\nJe kan de dots ook ordenen volgens grootte door de functie reorder() toe te voegen (x = reorder(species, count)) aan de x-aesthetic, analoog aan hoe we dit deden bij het maken van een geordende staafdiagram met geom_col(). De richting veranderen doe je door een “-” voor count te plaatsen (x = reorder(species, -count)).\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n  data = count_data,\n  aes(\n    x = reorder(species, count),\n    y = count\n    )\n  ) +\n  geom_point(\n    shape = 21,\n    size = 2,\n    color = \"black\",\n    fill = \"steelblue\"\n  ) +\n  labs(\n    x = \"Pinguïnsoort\",\n    y = \"Aantal\",\n    title = \"Dotplot van aantal pinguïns per soort\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.4 De dots labelen\nNet zoals bij het staafdiagram kan je de dots ook rechtsstreeks labelen door geom_text() toe te voegen aan de code. Hierbij wordt aangegeven dat de variabele count uit de dataset count_data moet worden gebruikt om de dots te labelen (aes(label = count)). Om ervoor te zorgen dat het label van de bovenste dot volledig wordt geplot, zijn de limieten van de y-as aangepast. Deze limieten geven aan wat de minimale en maximale waarde is die op de y-as wordt weergegeven. Daarom is ook de functie scale_y_continuous() toegevoegd aan de plot met als argument de juiste limieten (limits = c(0, 154)). In de functie wordt verder ook aangegeven dat er geen titel bij de y-as moet worden geplaatst (name = NULL). (De naam van de y-as is ook verwijderd uit de functie labs().) Speel met de limieten van de y-as in de code hieronder en kijk wat er gebeurt met de dotplot.\n\n\n\n\n\n\n\n\n2.5 Dots inkleuren volgens pinguïnsoort\nTot nu toe hebben we alle dots dezelfde kleur gegeven. Het is echter ook mogelijk om de dots in te kleuren volgens pinguïnsoort. Het enige dat we daarvoor dienen te doen, is twee ‘ingrediënten’ (aesthetics) toevoegen aan de dotplot. In de code hieronder vind je deze extra aesthetics terug in de aes()-functie (color = species en fill = species). We voegen hier zowel color als fill toe, omdat de shape die we gebruiken (shape ‘21’) een aparte kleur voor de vulling (fill) en voor de omtrek (color) toelaat. Vergeet ook niet om de argumenten voor color en fill die in geom_point() stonden weg te halen. Als je dat laatste niet doet, dan gebruikt ggplot2 de argumenten die in geom_point() staan (omdat deze argumenten verderop in de code staan en dus als laatste geëvalueerd worden).\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n  data = count_data,\n  aes(\n    x = reorder(species, count),\n    y = count,\n    color = species,\n    fill = species\n    )\n  ) +\n  geom_point(\n    shape = 21,\n    size = 2\n  ) +\n  geom_text(\n    aes(label = count),\n    vjust = -0.5,\n    size = 3,\n    color = \"grey50\"\n  ) +\n  scale_y_continuous(\n    limits = c(0, 154),\n    name = NULL\n    ) +\n  labs(\n    x = \"Pinguïnsoort\",\n    y = \"Aantal\",\n    title = \"Dotplot van aantal pinguïns per soort\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\"),\n    panel.grid = element_blank(),\n    axis.text.y = element_blank(),\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJe kan de kleuren zelf aanpassen met behulp van de functie scale_color_manual() (om de omtrek van de dots in te kleuren naar species) en scale_fill_manual() (om de opvulling van de dots in te kleuren naar species). Beide functies hebben één argument: values = c(\"darkorange\",\"purple\",\"cyan4\").",
    "crumbs": [
      "Visualiseren van één categorische variabele"
    ]
  },
  {
    "objectID": "03_categorisch.html#lollipop-plot",
    "href": "03_categorisch.html#lollipop-plot",
    "title": "Eén categorische variabele visualiseren",
    "section": "3 Lollipop plot",
    "text": "3 Lollipop plot\nEen dotplot is een goede opstap naar een lollipop plot. Hieronder vind je een voorbeeld van zo’n plot.\n\n\n\n\n\n\n\n\n\n\n3.1 Lollipop plot met geom_point() en geom_segment()\nAls je de code hieronder bekijkt, dan zal je merken dat er eigenlijk maar een beetje extra code is toegevoegd aan de code voor de dotplot. We vertrekken nog steeds van de count_data en de staven van de lollipop plot worden geordend op frequentie (x = reorder(species, count)). Om een lollipop plot te creëren, dien je verder alleen de geom geom_segment() toe te voegen. Deze geom plot een lijn (een segment) en heeft vier ingrediënten (aesthetics) nodig om te kunnen werken. De argumenten x en xend geven het start- en eindpunt van de lijn op de x-as weer. In dit geval is de variabele op de x-as categorisch van aard (species). Je geeft deze variabele dan op als start- én eindpunt. De argumenten y en yend doen hetzelfde maar dan voor de y-as. In een lollipop plot vertrekt de lijn steeds vanuit 0 (y = 0) en heeft als eindpunt de frequentie van het aantal pinguïns (voor die soort). Aangezien die laatsten vervat zijn in de variabele count plaats je deze achter yend.\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\ncount_data %&gt;%\n  ggplot(\n    aes(\n      x = reorder(species, count),\n      y = count\n      )\n    ) + \n  geom_point( \n  ) +  \n  geom_segment(  \n    aes(\n      x = species,\n      xend = species, \n      y = 0,\n      yend = count\n      )\n    ) +\n   labs(\n    x = \"Pinguïnsoort\",\n    y = \"Aantal\",\n    title = \"Dotplot van aantal pinguïns per soort\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.2 De dots labelen\nDe dots kunnen opnieuw gelabeld worden. Kopieer daarover de nodige code (zie Paragraaf 2.4) en plak deze in het codeblock hieronder. De code om de titel van de y-as, de labels op de y-as en de gridlijnen te verwijderen, is al toegevoegd (scale_y_continuous(name = NULL)).\n\n\n\n\n\n\n\n\n3.3 Inkleuren volgens pinguïnsoort\nDe lollipop plot kan vervolgens ook ingekleurd worden volgens pinguïnsoort. Daartoe dienen we twee extra aesthetics toe te voegen aan de ggplot()-functie: color = species en fill = species. Door dit in de ggplot()-functie toe te voegen, zal dit worden toegepast op alle geoms die we verder gebruiken. M.a.w. zowel in geom_point() als geom_segment() worden de geoms nu ingekleurd volgens pinguïnsoort. Merk op dat we ook de functie scale_color_manual() toevoegde aan de code.\nKopieer de code hieronder naar RStudio op je eigen laptop enprobeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\ncount_data %&gt;%\n  ggplot(\n    aes(\n      x = reorder(species, count),\n      y = count,\n      color = species,\n      fill = species\n      )\n    ) + \n  geom_point( \n  ) +  \n  geom_segment(  \n    aes(\n      x = species,\n      xend = species, \n      y = 0,\n      yend = count\n      )\n    ) +\n  geom_text(\n    aes(label = count),\n    vjust = -0.5,\n    size = 3,\n    color = \"grey50\"\n  ) +\n  scale_y_continuous(name=NULL) +\n  labs(\n    x = \"Pinguïnsoort\",\n    title = \"Dotplot van aantal pinguïns per soort\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\"\n  ) +\n  scale_color_manual(\n    values = c(\"darkorange\",\"purple\",\"cyan4\")\n) +\n  scale_fill_brewer(\n    values = c(\"darkorange\",\"purple\",\"cyan4\")\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\"),\n    panel.grid = element_blank(),\n    axis.text.y = element_blank(),\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.4 Labels bij dots inkleuren\nZowel de lijnen als punten van de lollipop plot zijn ingekleurd volgens pinguïnsoort. Je vindt het misschien vreemd dat de tekst bij de dots nog steeds in het grijs is? Hierboven gaven we immers aan dat het toevoegen van color = species en fill = species aan de ggplot()-functie ervoor zorgt dat dit op alle geoms wordt toegepast. Waarom is dit dan niet togepast op geom_text()? Hieronder vind je de code terug. Welke codelijn moet je schrappen om ervoor te zorgen dat ook de labels bij de dots in de juiste kleur worden geplot? Schrap die code en probeer dit uit.\n\n\n\n\n\n\nDoor color = \"grey50\" als argument te verwijderen uit geom_text() worden ook de labels van de dots in de juiste kleur geplot. Dit argument zorgde er immers voor dat het color- en fill-argument uit de ggplot()-functie werd ‘overruled’. Je hebt misschien ook gemerkt dat de legende verdwenen is? Dit kan door het argument legend.position = \"none\" toe te voegen aan theme(). De legende verwijderen is hier mogelijk gemaakt door de labels op de x-as naar boven te verplaatsen. Voor dat laatste werd de functie scale_x_discrete() gebruikt (scale_x_discrete() en niet scale_x_continuous() omdat de variabele op de x-as categorisch van aard is). Met het argument position = \"top\" geef je aan dat je wil dat de x-as bovenaan de plot wordt geplaatst.",
    "crumbs": [
      "Visualiseren van één categorische variabele"
    ]
  },
  {
    "objectID": "03_categorisch.html#overzicht-van-functies-en-argumenten-uit-hoofdstuk-3",
    "href": "03_categorisch.html#overzicht-van-functies-en-argumenten-uit-hoofdstuk-3",
    "title": "Eén categorische variabele visualiseren",
    "section": "4 Overzicht van functies en argumenten uit hoofdstuk 3",
    "text": "4 Overzicht van functies en argumenten uit hoofdstuk 3\nDe onderstaande functies en argumenten zijn in dit hoofdstuk aan bod gekomen:\n\nfuncties geom_bar() en geom_col() met aesthetics x, y, color en fill en de argumenten width, fill en color\n\nfunctie geom_text() en de argumenten label, stat, vjust, size en color\nfunctie geom_point() en de argumenten shape, size, fill en color\n\nfunctie geom_segment() en de argumenten x, xend, y en yend\n\nfuncties scale_x_discrete() en scale_y_continuous() met de argumenten limits en name\n\nfunctie scale_color_manual() met het argument values\nfunctie labs() met de argumenten title, subtitle, x en y\nfunctie coord_flip()\nfuncties fct_infreq() en fct_rev()\nfunctie reorder()\n\nLet op! De meeste functies beschikken over veel meer argumenten dan deze die in dit hoofdstuk aan bod zijn gekomen. Om hier een overzicht van te krijgen, kan je de help-functie gebruiken. Ook de specifieke aesthetics die je kan toevoegen aan elke *geom*-functie zijn uitgebreider dan je hier terug vindt. Daarover meer in de volgende hoofdstukken.",
    "crumbs": [
      "Visualiseren van één categorische variabele"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Datavisualisatie met ggplot2",
    "section": "",
    "text": "Dit leertraject introduceert je in het creëren van datavisualisaties met behulp van het R-package ggplot2. Daarbij is het geenzins de bedoeling om je alle mogelijke types grafieken te leren maken. (Dat is onmogelijk!) Het is wel de bedoeling om je de basisprincipes achter ggplot2 mee te geven zodat je nadien zelf gemakkelijk andere types visualisaties kan maken. De focus ligt dus voornamelijk op het gebruik van ggplot2 en niet (of slechts in beperkte mate) op principes van goede datavisualisatie. Dat neemt niet weg dat er doorheen het leertraject wel af en toe verwezen wordt naar deze principes. Hieronder vind je een overzicht van de leerdoelen van dit leertraject.\n\n\n\n\n\n\nLeerdoelen\n\n\n\nNa het doornemen van dit leertraject zal je:\n\nvertrouwd zijn met de verschillende ‘ingrediënten’ van een ggplot (aesthetics, geoms, scales, labs, theme);\n\nzelf een visualisatie kunnen creëren van één kwalitatieve of kwantitatieve variabele;\n\nzelf een visualisatie kunnen creëren van twee of meer variabelen;\n\nde ‘look’ van een visualisatie kunnen aanpassen;\n\nkennismaken met enkele packages die extensies op ggplot2 aanbieden.\n\n\n\nEr is maar één manier om vertrouwd te raken met ggplot2 en dat is door er zelf mee aan de slag gaan. Je zal dan ook regelmatig gevraagd worden om code uit te proberen door deze te kopiëren naar je eigen script (op je eigen laptop) of door ‘live’ code te runnen. Om dat laatste mogelijk te maken, gebruiken we het package webR. Dit package opstarten en de nodige zaken ervoor preparen vraagt telkens even tijd. Daarom laden we hier al de nodige packages en data in. De warnings en andere boodschappen die je krijgt, mag je gewoon negeren.\n\n\n\n\n\n\nDit leertraject bestaat uit verschillende hoofdstukken. Je neemt best de hoofdstukken in de aangegeven volgorde door. Functies en argumenten die je in het ene hoofdstuk leert, worden in de volgende hoofdstukken slechts kort (of niet) herhaald. Op het einde van elk hoofdstuk vind je een overzicht van de functies en argumenten die in dat hoofdstuk aan bod kwamen.\nVeel ggplot2-plezier!",
    "crumbs": [
      "Welkom"
    ]
  },
  {
    "objectID": "01_intro.html#voor-je-aan-de-slag-kan",
    "href": "01_intro.html#voor-je-aan-de-slag-kan",
    "title": "1 Introductie van ggplot2",
    "section": "1.3 Voor je aan de slag kan",
    "text": "1.3 Voor je aan de slag kan\nGenoeg gepraat over het maken van visualisaties, hoog tijd om zelf aan de slag te gaan met ggplot2! Daarvoor hebben we twee dingen nodig: het R-package ggplot2 en data om te plotten. Een leuke dataset om mee te werken, is de Palmer Penguin data. Deze dataset is afkomstig van onderzoek uitgevoerd door Kristen Gorman op het Palmer Station (Antarctica). Meer info over de Palmer Penguins data vind je hier. De data bevat metingen en observaties over drie pinguïnsoorten (Adélie, Kinband en Gentoo) en werden verzameld in 2007, 2008 en 2009. Om de pinguïndata te visualiseren, dien je eerst de packages tidyverse en palmerpenguins te installeren en laden. Het laatste package bevat de pinguïndata. De tidyverse is een verzameling van R-packages die speciaal ontworpen is om je codeeRweRk een pak intuïtiever, efficiënter en dus ook eenvoudiger te maken. Hoewel dit leertraject zich focust op datavisualisatie met ggplot2, introduceren we ook enkele functies uit het dplyr-package (dat ook bij de tidyverse hoort).\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"palmerpenguins\")\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\ndplyr is een pakket speciaal ontworpen om datamanipulatie piece of cake te maken voor de gebruiker. Als er functies uit dplyr worden gebruikt, dan worden deze kort toegelicht in de code zelf. Wil je een uitgebreidere introductie van dplyr, dan vind je hier een korte tutorial. Wil je meer weten over de tidyverse en de verschillende packages die er deel van uit maken, dan is het boek R for data science een goed vertrekpunt!\nMaar nu genoeg over de tidyverse terug naar de pinguïns! Eerst laad je de data in RStudio via de functie data.\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"palmerpenguins\")\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\ndata(\"penguins\")\n\nBekijk vervolgens tien random rijen uit de dataset met behulp van de functie slice_sample() (functie uit dplyr).\n\n# Sample 10 random rijden (n = 10) uit de data `penguins`\nslice_sample(penguins, n = 10)\n\n# A tibble: 10 × 8\n   species   island   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;     &lt;fct&gt;             &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Gentoo    Biscoe             44.9          13.8               212        4750\n 2 Adelie    Biscoe             35.7          16.9               185        3150\n 3 Gentoo    Biscoe             50.4          15.7               222        5750\n 4 Chinstrap Dream              58            17.8               181        3700\n 5 Adelie    Biscoe             40.6          18.6               183        3550\n 6 Adelie    Torgers…           36.2          17.2               187        3150\n 7 Gentoo    Biscoe             45.1          14.4               210        4400\n 8 Adelie    Biscoe             39.6          17.7               186        3500\n 9 Chinstrap Dream              45.2          16.6               191        3250\n10 Gentoo    Biscoe             44.9          13.3               213        5100\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nCheck via glimpse() welke variabelen in de dataset zitten en hoe deze gedefineerd zijn (als factor, …).\n\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nIn de dataset vind je de volgende acht variabelen terug:\n- snavellengte (bill_length_mm)\n- snaveldiepte (bill_depth_mm)\n- vleugellengte (flipper_length_mm)\n- lichaamsgewicht (body_mass_g)\n- geslacht (sex)\n- soort (species)\n- kolonielocatie (island)\n- jaar van observatie (year)",
    "crumbs": [
      "Introductie van `ggplot2`"
    ]
  },
  {
    "objectID": "01_intro.html#voor-je-aan-de-slag-gaat",
    "href": "01_intro.html#voor-je-aan-de-slag-gaat",
    "title": "Introductie van ggplot2",
    "section": "3 Voor je aan de slag gaat",
    "text": "3 Voor je aan de slag gaat\nGenoeg gepraat over het maken van visualisaties, hoog tijd om zelf aan de slag te gaan met ggplot2! Daarvoor hebben we twee dingen nodig: het R-package ggplot2 en data om te plotten. Een leuke dataset om mee te werken, is de Palmer Penguin data. Deze dataset is afkomstig van onderzoek uitgevoerd door Kristen Gorman op het Palmer Station (Antarctica). Meer info over de Palmer Penguins data vind je hier. De data bevat metingen en observaties over drie pinguïnsoorten (Adélie, Kinband en Gentoo) en werden verzameld in 2007, 2008 en 2009. Om de pinguïndata te visualiseren, dien je eerst de packages tidyverse en palmerpenguins te installeren en laden. Het laatste package bevat de pinguïndata. De tidyverse is een verzameling van R-packages die speciaal ontworpen is om je codeeRweRk een pak intuïtiever, efficiënter en dus ook eenvoudiger te maken. Hoewel dit leertraject zich focust op datavisualisatie met ggplot2, introduceren we ook enkele functies uit het dplyr-package (dat ook bij de tidyverse hoort).\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"palmerpenguins\")\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\ndplyr is een pakket speciaal ontworpen om datamanipulatie piece of cake te maken voor de gebruiker. Als er functies uit dplyr worden gebruikt, dan worden deze kort toegelicht in de code zelf. Wil je een uitgebreidere introductie van dplyr, dan vind je hier een korte tutorial. Wil je meer weten over de tidyverse en de verschillende packages die er deel van uit maken, dan is het boek R for data science een goed vertrekpunt!\nMaar nu genoeg over de tidyverse terug naar de pinguïns! Eerst laad je de data in RStudio via de functie data.\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"palmerpenguins\")\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\ndata(\"penguins\")\n\nBekijk vervolgens tien random rijen uit de dataset met behulp van de functie slice_sample() (functie uit dplyr).\n\n# Sample 10 random rijden (n = 10) uit de data `penguins`\nslice_sample(penguins, n = 10)\n\n# A tibble: 10 × 8\n   species   island   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;     &lt;fct&gt;             &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Gentoo    Biscoe             44.9          13.8               212        4750\n 2 Adelie    Biscoe             35.7          16.9               185        3150\n 3 Gentoo    Biscoe             50.4          15.7               222        5750\n 4 Chinstrap Dream              58            17.8               181        3700\n 5 Adelie    Biscoe             40.6          18.6               183        3550\n 6 Adelie    Torgers…           36.2          17.2               187        3150\n 7 Gentoo    Biscoe             45.1          14.4               210        4400\n 8 Adelie    Biscoe             39.6          17.7               186        3500\n 9 Chinstrap Dream              45.2          16.6               191        3250\n10 Gentoo    Biscoe             44.9          13.3               213        5100\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nCheck via glimpse() welke variabelen in de dataset zitten en hoe deze gedefineerd zijn (als factor, …).\n\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nIn de dataset vind je de volgende acht variabelen terug:\n- snavellengte (bill_length_mm)\n- snaveldiepte (bill_depth_mm)\n- vleugellengte (flipper_length_mm)\n- lichaamsgewicht (body_mass_g)\n- geslacht (sex)\n- soort (species)\n- kolonielocatie (island)\n- jaar van observatie (year)",
    "crumbs": [
      "Introductie van `ggplot2`"
    ]
  },
  {
    "objectID": "01_intro.html#een-plot-laagje-per-laagje-opbouwen",
    "href": "01_intro.html#een-plot-laagje-per-laagje-opbouwen",
    "title": "Introductie van ggplot2",
    "section": "5 Een plot laagje per laagje opbouwen",
    "text": "5 Een plot laagje per laagje opbouwen\nJe bouwde net je allereerste visualisatie in ggplot2laagje voor laagje op! Uiteraard kan je nog veel meer zaken toevoegen. Hieronder vind je een uitgebreider voorbeeld terug.\n\n\n\n\n\n\n\n\n\nWe leggen stap per stap uit wat er precies wordt toegevoegd aan de plot. Daarbij wordt ook de nodige code meegegeven. Je zal merken dat er in de code gebruik gemaakt wordt van functies uit dplyr. Je vindt twee manieren terug om code ‘aan elkaar te rijgen’. In ggplot2 gebeurt dit met behulp van een +. dplyr maakt echter gebruik van de pipe (%&gt;%) om verschillende commando’s aan elkaar te rijgen.\nLaag 1 De basis van de plot wordt gelegd met de functie ggplot(). Er wordt aangegeven dat de variabele flipper_length_mm op de x-as dient te komen en de variabele body_mass_g op de y-as. De plot wordt weggeschreven naar een object met de naam ‘P1’.\n\nP1 &lt;- \n  ## Gebruik de dataset penguins\n  penguins %&gt;%\n  ## Gebruik alleen rijen waarin sex NIET NA is \n  filter(!is.na(sex)) %&gt;%\n  ggplot(aes(x = flipper_length_mm, y = body_mass_g )) \n\nLaag 2 Er wordt een geom toegevoegd aan de plot P1 (geom_point()).\n\nP2 &lt;- \n  P1 + \n  geom_point() \n\nLaag 3 Om de datapunten een andere vorm en kleur te geven naar geslacht, worden in geom_point() nieuwe ingrediënten (aesthetics) toegevoegd d.m.v. aes(color = sex, shape = sex). Omdat de datapunten soms overlappen, wordt er transparantie toegevoegd aan de punten (alpha = .8) en ook de grootte van de punten wordt aangepast (size = 3). Tenslotte wordt er ook aangegeven welke kleuren er gebruikt dienen te worden via scale_color_manual(values = c(\"darkorange\", \"purple\")).\n\nP3 &lt;- \n  P2 +\n  geom_point(\n    aes(color = sex, shape = sex), \n    alpha = .8, \n    size = 3    \n    ) +\n  scale_color_manual(\n    values = c(\"darkorange\",\"purple\")\n    ) \n\nLaag 4 In de vierde stap wordt een trendlijn toegevoegd aan de plot. Hiervoor wordt een tweede geom gebruikt: geom_smooth(). Met het argument method = \"lm\" geven we aan dat we een lineaire trendlijn willen.\n\nP4 &lt;- P3 + geom_smooth(method = \"lm\") \n\nLaag 5 We willen graag een aparte trendlijn voor de mannelijke en vrouwelijke pinguïns. Dit wordt aangegeven door aes(color = sex) toe te voegen aan de functie geom_smooth(). Het argument se = F geeft aan dat we GEEN betrouwbaarheidsinterval rond de trendlijnen willen.\n\nP5 &lt;- P3 +\n  geom_smooth(\n    aes(color = sex),\n    se = F,\n    method = \"lm\"\n    )\n\nLaag 6 De labels van de x- en y-as krijgen een andere naam via de functies scale_x_continuous() en scale_y_continuous().\n\nP6 &lt;- \n  P5 +\n  scale_x_continuous(\"Flipper length (mm)\") +\n  scale_y_continuous(\"Body Mass (g)\")\n\nLaag 7 In de zevende stap wordt het plot-thema aangepast naar theme_minimal().\n\nP7 &lt;- P6 + theme_minimal()\n\nLaag 8 De laatste stap bestaat uit het toevoegen van een titel en subtitel. Hiervoor wordt de labs()-functie gebruikt (via de argumenten title en subtitle.\n\nP8 &lt;- P7 +\n  labs(\n    title = \"Palmer penguins\",\n    subtitle = \"Flipper length and body mass for both sexes\"\n    )\n\nNa deze korte introductie duiken we verder de wereld van ggplot2 in.",
    "crumbs": [
      "Introductie van `ggplot2`"
    ]
  },
  {
    "objectID": "01_intro.html#sec-plotbase",
    "href": "01_intro.html#sec-plotbase",
    "title": "Introductie van ggplot2",
    "section": "1 De plotfuncties in R?",
    "text": "1 De plotfuncties in R?\nWie een beetje vertrouwd is met R weet dat er standaard verschillende plot-functies in R zitten. Voorbeelden daarvan zijn de functies hist(), boxplot() en uiteraard ook plot(). Hieronder vind je een voorbeeld van een histogram, een boxplot en een scatterplot gecreëerd met deze functies. De plot()-functie is bijzonder omdat de output van deze functie zich aanpast aan de input die het krijgen. Geef je plot() twee kwantitatieve variabelen mee? Dan tovert plot() een scatterplot te voorschijn (zoals in het voorbeeld hierboven). Krijgt plot() een tabel als input? Dan wordt er een staafdiagram gecreëerd. De plot-functies die standaard in R zitten, bieden dus al de nodige mogelijkheden. Waarom is er dan nood aan een bijkomend R-package dat zich specifiek richt op visualisatie?\n\nhist()boxplot()plot()\n\n\n\nhist(data$x, xlab = \"x\") \n\n\n\n\n\n\n\n\n\n\n\nboxplot(data$y, xlab = \"y\") \n\n\n\n\n\n\n\n\n\n\n\nplot(data$x, data$y, xlab = \"x\", ylab = \"y\")\n\n\n\n\n\n\n\n\n\n\n\nggplot2 biedt enkele voordelen ten opzichte van de plot-functies die standaard in R zitten. Ten eerste is ggplot2 veel flexibeler in gebruik dan de standaard plot-functies. De functies hist() of boxplot() laten bijvoorbeeld alleen maar toe om een specifiek soort grafiek te creëren. Je kan wel zaken aanpassen (bv. de kleur van een histogram) of toevoegen aan de plots (bv. een titel), maar deze mogelijkheden zijn vrij beperkt. Daarnaast is het ook niet zo evident om alle soorten visualisaties te creëren met de standaard plot-functies. ggplot2 en de vele packages die erop verderbouwen laten je toe om elk type grafiek te creëren dat je wenst. Ten slotte is het ggplot2 gebaseerd op een theorie over datavisualisatie, de Grammar of Graphics. Zoals de naam van de theorie al suggereert, is ggplot2 gebaseerd op een generieke ‘taal’ (grammatica) voor het creëren van visualisaties. Dit maakt het gebruik van ggplot2 veel intuïtiever dan dat van de standaard plot-functies in R.",
    "crumbs": [
      "Introductie van `ggplot2`"
    ]
  },
  {
    "objectID": "01_intro.html#sec-grammar",
    "href": "01_intro.html#sec-grammar",
    "title": "Introductie van ggplot2",
    "section": "2 Grammar of graphics",
    "text": "2 Grammar of graphics\nHet package ggplot2 volgt de principes van de Grammar of Graphics. De Grammar of Graphics is een ‘taal’ ontworpen door Leland Wilkinson om grafieken te creëren. Wilkinson was een Amerikaanse statisticus en expert op het gebied van datavisualisatie. Hij introduceerde het concept in zijn boek “The Grammar of Graphics” (1999). Volgens de Grammar of Graphics kan elke visualisatie worden opgesplitst in dezelfde componenten (layers in Grammar of Graphics-taal). Voorbeelden van zulke layers zijn data, geometrische objecten en facetten. De Grammar of Graphics is dus een universeel systeem om visualisaties te creëren dat de basis vormt voor verschillende moderne visualisatietools (waaronder dus ook ggplot2).\nHet basisidee achter ggplot2 is dat je een plot in laagjes opbouwt. Er worden zeven verschillende soorten laagjes (layers) onderscheiden: data, aesthetics (bv. variabele op de x- en y-as), geometries (bv. histogram, lijngrafiek), facets, statistics (bv. regressielijn), coordinates en theme. Elke laag voegt een nieuw element toe aan de plot. De animatie hieronder is overgenomen van Thomas de Beus en illustreert hoe een ggplot wordt opgebouwd aan de hand van verschillende layers.\n\n Een visualisatie maken in ggplot2 doe je dus laagje per laagje, een beetje zoals je een cake bakt. Op de figuur hieronder zie je hoe elk onderdeel van de cake overeenkomt met een layer in ggplot2. Als je een cake bakt, start je altijd met het leggen van de basis. In ggplot2 doe je dat met de functie ggplot(). Elke visualisatie start dus met deze functie. Vervolgens specificeer je de ingrediënten met behulp van de functie [aes()] en de smaken met de functie scale_(). Dan voeg je laagjes toe aan je cake in de vorm van een [geom]. Ten slotte kan je de cake naar eigen believen afwerken (‘stylen’) door middel van de functie theme().    Figuur overgenomen van Tanya Shapiro",
    "crumbs": [
      "Introductie van `ggplot2`"
    ]
  },
  {
    "objectID": "01_intro.html#sec-aandeslag",
    "href": "01_intro.html#sec-aandeslag",
    "title": "Introductie van ggplot2",
    "section": "3 Aan de slag?",
    "text": "3 Aan de slag?\nGenoeg gepraat over het maken van visualisaties, hoog tijd om zelf aan de slag te gaan met ggplot2! Daarvoor hebben we twee dingen nodig: het R-package ggplot2 én data om te plotten. Een leuke dataset om mee te werken, is de Palmer Penguin data. Deze dataset is afkomstig van onderzoek uitgevoerd door Kristen Gorman op het Palmer Station (Antarctica). Deze dataset bevat metingen en observaties over drie pinguïnsoorten (Adélie, Kinband en Gentoo) en werd verzameld in 2007, 2008 en 2009. Om de pinguïndata te kunnen gebruiken en visualiseren, dien je eerst de packages tidyverse en palmerpenguins te installeren en laden.\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"palmerpenguins\")\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\nDe tidyverse is een verzameling van R-packages (waaronder ggplot2) dat speciaal ontworpen is om je codeeRweRk een pak intuïtiever, efficiënter en dus ook eenvoudiger te maken. Hoewel dit leertraject zich focust op datavisualisatie met ggplot2, introduceren we ook enkele functies uit het dplyr-package (dat ook bij de tidyverse hoort) dat speciaal ontworpen is om datamanipulatie piece of cake te maken. Als er functies uit dplyr worden gebruikt, dan worden deze kort toegelicht in de code zelf. Wil je een uitgebreidere introductie van dplyr, dan vind je hier een korte tutorial. Wil je meer weten over de tidyverse en de verschillende packages die er deel van uit maken, dan is het boek R for data science een goed vertrekpunt!\nMaar nu genoeg over de tidyverse terug naar de pinguïns! Laad de data in RStudio via de functie data().\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"palmerpenguins\")\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\ndata(\"penguins\")\n\nBekijk vervolgens tien random rijen uit de dataset met behulp van de functie slice_sample().\n\n# Sampel 10 random rijden (n = 10) uit de data `penguins`\nslice_sample(penguins, n = 10)\n\n# A tibble: 10 × 8\n   species   island   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;     &lt;fct&gt;             &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Gentoo    Biscoe             44.9          13.8               212        4750\n 2 Adelie    Biscoe             35.7          16.9               185        3150\n 3 Gentoo    Biscoe             50.4          15.7               222        5750\n 4 Chinstrap Dream              58            17.8               181        3700\n 5 Adelie    Biscoe             40.6          18.6               183        3550\n 6 Adelie    Torgers…           36.2          17.2               187        3150\n 7 Gentoo    Biscoe             45.1          14.4               210        4400\n 8 Adelie    Biscoe             39.6          17.7               186        3500\n 9 Chinstrap Dream              45.2          16.6               191        3250\n10 Gentoo    Biscoe             44.9          13.3               213        5100\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nCheck via glimpse() welke variabelen in de dataset zitten en hoe deze gedefineerd zijn (als factor, …).\n\n# Functie die overzicht van variabelen in dataset geeft \nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nIn de dataset vind je de volgende acht variabelen terug:\n- snavellengte (bill_length_mm)\n- snaveldiepte (bill_depth_mm)\n- vleugellengte (flipper_length_mm)\n- lichaamsgewicht (body_mass_g)\n- geslacht (sex)\n- soort (species)\n- kolonielocatie (island)\n- jaar van observatie (year)\nMeer info over deze variabelen en de Palmer Penguins data vind je hier.",
    "crumbs": [
      "Introductie van `ggplot2`"
    ]
  },
  {
    "objectID": "01_intro.html#sec-notendop",
    "href": "01_intro.html#sec-notendop",
    "title": "Introductie van ggplot2",
    "section": "4 ggplot2 in een notendop",
    "text": "4 ggplot2 in een notendop\nNu je een beetje vertrouwd bent met de pinguïndata kunnen we aan de slag met ggplot2! We bouwen een eerste visualisatie stap voor stop op en focussen daarbij op enkele typische layers (laagjes) die je in elke ggplot terugvindt.\n\n4.1 Data en aesthetics\nJe start in ggplot2 steeds met de functie ggplot(). In deze functie geef je aan welke data je wil gebruiken (data = penguins) en je specificeert ook de aesthetics. De aesthetics vormen de ingrediënten van je plot. Het zijn de variabelen die je wil plotten. De aesthetics specificeren doe je aan de hand van de functie aes(). In dit geval willen we de variabele flipper_length_mm op de x-as en de variabele body_mass_g op de y-as.\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Zorg dat de packages tidyverse en palmerpenguins geladen zijn. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n\n  ## Stap 1: data\n  data = penguins,\n  \n  ## Stap 2: aesthetics specificeren (mapping)\n  aes(\n    x = flipper_length_mm,\n    y = body_mass_g)\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.2 Geometries\nDe vorige code levert een lege plot op! Dit komt omdat je alleen de basis voor je plot hebt gelegd (met de functie ggplot()), maar niet hebt aangegeven welk geometrisch object (geom in ggplot2-taal) je wilt gebruiken. Een geom representeert de visuele elementen die worden gebruikt om gegevens weer te geven in de plot. Elke geom komt overeen met een specifiek type grafische representatie, zoals punten, lijnen, balken of gebieden. Geoms bepalen dus hoe de gegevens visueel worden weergegeven. In ons voorbeeld voegen we de geom_point() functie toe. Deze functie geeft elk datapunt weer als een punt op de plot? Vul je code aan en evalueer het resultaat. Je krijgt een warning. Wat betekent deze warning?\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n\n  ## Stap 1: data\n  data = penguins,\n  \n  ## Stap 2: aesthetics specificeren (mapping)\n  aes(\n    x = flipper_length_mm,\n    y = body_mass_g)\n) +\n  ## Stap 3: voeg geometry toe\n  geom_point()\n\n\n\n\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\nDe warning wijst erop dat er twee ontbrekende observaties zijn (en dat deze uiteraard niet geplot zijn).\n\n\n4.3 Facets\nStel dat we het verband tussen het lichaamsgewicht en vleugellengte per pinguïnsoort willen plotten. We willen m.a.w een aparte scatterplot per soort (small multiples). Dit kan je heel eenvoudig realiseren met behulp van de functie facet_wrap(). Tussen de haakjes geef je aan op basis van welke variabele de facets moeten worden gecreëerd (in dit geval species). Deze variabele dient vooraf gegaan te worden door een tilde (~).\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n\n  ## Stap 1: data\n  data = penguins,\n  \n  ## Stap 2: aesthetics specificeren (mapping)\n  aes(\n    x = flipper_length_mm,\n    y = body_mass_g)\n) +\n  ## Stap 3: voeg geometry toe\n  geom_point() +\n  \n  ## Stap 4: definieer facets\n  facet_wrap(~species)\n\n\n\n\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.4 Theme\nIn een laatste stap passen we het plot-thema aan. Als je geen plot-thema meegeeft, dan gebruikt deze het default plot-thema. Dit plot-thema heeft echter een grijze achtergrond die verder niets bijdraagt aan de plot (chart junk!). Verander daarom het plot-thema naar theme_minimal(). Voeg dit plot-thema standaard toe aan alle plots die je creëert!\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n\n  ## Stap 1: data\n  data = penguins,\n  \n  ## Stap 2: aesthetics specificeren (mapping)\n  aes(\n    x = flipper_length_mm,\n    y = body_mass_g)\n) +\n  ## Stap 3: voeg geometry toe\n  geom_point() +\n  \n  ## Stap 4: definieer facets\n  facet_wrap(~species) +\n  \n  ## Stap 5: pas thema aan\n  theme_minimal()\n\n\n\n\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).",
    "crumbs": [
      "Introductie van `ggplot2`"
    ]
  },
  {
    "objectID": "01_intro.html#sec-laag",
    "href": "01_intro.html#sec-laag",
    "title": "Introductie van ggplot2",
    "section": "5 Een plot laagje per laagje opbouwen",
    "text": "5 Een plot laagje per laagje opbouwen\nJe bouwde net je allereerste visualisatie in ggplot2laagje voor laagje op! Uiteraard kan je nog veel meer zaken toevoegen. Hieronder vind je een uitgebreider voorbeeld terug.\n\n\n\n\n\n\n\n\n\nWe leggen stap per stap uit wat er precies wordt toegevoegd aan de plot. Daarbij wordt ook de nodige code meegegeven. Je zal merken dat er in de code gebruik gemaakt wordt van functies uit dplyr. Je vindt twee manieren terug om code ‘aan elkaar te rijgen’. In ggplot2 gebeurt dit met behulp van een +. dplyr maakt echter gebruik van de pipe (%&gt;%) om verschillende commando’s aan elkaar te rijgen.\nLaag 1 De basis van de plot wordt gelegd met de functie ggplot(). Er wordt aangegeven dat de variabele flipper_length_mm op de x-as dient te komen en de variabele body_mass_g op de y-as. De plot wordt weggeschreven naar een object met de naam ‘P1’.\n\nP1 &lt;- \n  ## Gebruik de dataset penguins\n  penguins %&gt;%\n  ## Gebruik alleen rijen waarin sex NIET NA is \n  filter(!is.na(sex)) %&gt;%\n  ggplot(aes(x = flipper_length_mm, y = body_mass_g )) \n\nLaag 2 Er wordt een geom toegevoegd aan de plot P1 (geom_point()).\n\nP2 &lt;- \n  P1 + \n  geom_point() \n\nLaag 3 Om de datapunten een andere vorm en kleur te geven naar geslacht, worden in geom_point() nieuwe ingrediënten (aesthetics) toegevoegd d.m.v. aes(color = sex, shape = sex). Omdat de datapunten soms overlappen, wordt er transparantie toegevoegd aan de punten (alpha = .8) en ook de grootte van de punten wordt aangepast (size = 3). Tenslotte wordt er ook aangegeven welke kleuren er gebruikt dienen te worden via scale_color_manual(values = c(\"darkorange\", \"purple\")).\n\nP3 &lt;- \n  P2 +\n  geom_point(\n    aes(color = sex, shape = sex), \n    alpha = .8, \n    size = 3    \n    ) +\n  scale_color_manual(\n    values = c(\"darkorange\",\"purple\")\n    ) \n\nLaag 4 In de vierde stap wordt een trendlijn toegevoegd aan de plot. Hiervoor wordt een tweede geom gebruikt: geom_smooth(). Met het argument method = \"lm\" geven we aan dat we een lineaire trendlijn willen.\n\nP4 &lt;- P3 + geom_smooth(method = \"lm\") \n\nLaag 5 We willen graag een aparte trendlijn voor de mannelijke en vrouwelijke pinguïns. Dit wordt aangegeven door aes(color = sex) toe te voegen aan de functie geom_smooth(). Het argument se = F geeft aan dat we GEEN betrouwbaarheidsinterval rond de trendlijnen willen.\n\nP5 &lt;- P3 +\n  geom_smooth(\n    aes(color = sex),\n    se = F,\n    method = \"lm\"\n    )\n\nLaag 6 De labels van de x- en y-as krijgen een andere naam via de functies scale_x_continuous() en scale_y_continuous().\n\nP6 &lt;- \n  P5 +\n  scale_x_continuous(\"Flipper length (mm)\") +\n  scale_y_continuous(\"Body Mass (g)\")\n\nLaag 7 In de zevende stap wordt het plot-thema aangepast naar theme_minimal().\n\nP7 &lt;- P6 + theme_minimal()\n\nLaag 8 De laatste stap bestaat uit het toevoegen van een titel en subtitel. Hiervoor wordt de labs()-functie gebruikt (via de argumenten title en subtitle.\n\nP8 &lt;- P7 +\n  labs(\n    title = \"Palmer penguins\",\n    subtitle = \"Flipper length and body mass for both sexes\"\n    )\n\nNa deze korte introductie duiken we verder de wereld van ggplot2 in.",
    "crumbs": [
      "Introductie van `ggplot2`"
    ]
  },
  {
    "objectID": "02_numeriek.html#sec-histogram",
    "href": "02_numeriek.html#sec-histogram",
    "title": "Eén numerieke variabele visualiseren",
    "section": "1 Een histogram",
    "text": "1 Een histogram\nEen eerste mogelijkheid om de verdeling van de variabele flipper_length_mm te visualiseren is een histogram. Hieronder vind je een voorbeeld van een histogram (die je op het einde van dit deel zelf zal kunnen maken).\n\n\n\n\n\n\n\n\n\nOm te leren hoe je een histogram creëert in ggplot2 hanteren we de volgende opbouw (die je telkens zal zien terugkomen):\n- je leert het geom om een histogram te plotten;\n- je maakt kennis met de basisargumenten van de functie geom_histogram();\n- je leert één of meerdere generieke aspecten van het histogram aanpassen.\nMet generieke aspecten bedoelen we zaken die je niet alleen bij het creëren van een histogram kan toepassen, maar ook bij het maken van elk ander type grafiek. Op het einde van het hoofstuk vind je een overzicht van alle functies die je in dat hoofdstuk leerde.\n\n1.1 Histogram met geom_histogram()\nOm een histogram te plotten, maak je gebruik van het geom (de functie) geom_histogram(). Deze functie heeft één ingrediënt (aesthetic) nodig: een x-variabele (x = flipper_length_mm in het voorbeeld hieronder).\nKopieer de code hieronder naar een script in RStudio op je eigen laptop en probeer de code uit. Zorg dat de packages tidyverse en palmerpenguins geladen zijn. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n  data = penguins,\n  aes(\n    x = flipper_length_mm,\n    )\n  ) +\n  geom_histogram() +\n  theme_minimal()\n\n\n\n\n\n`stat_bin()` using `bins = 30`. Pick better value `binwidth`.\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\n\n\nBij het uitvoeren van de code krijg je zowel een warning als een boodschap. De warning verwijst naar twee ontbrekende waarden in de variabele flipper_length_mm. Dit kan je checken via summary().\n\nsummary(penguins$flipper_length_mm)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  172.0   190.0   197.0   200.9   213.0   231.0       2 \n\n\nJe krijgt ook nog een andere boodschap: stat_bin() using bins = 30. Pick better value with binwidth. Dit verwijst naar de manier waarop geom_histogram() de breedte van de ‘bins’ bepaalt. Meer daarover hieronder!\n\n\n1.2 Basisargumenten van geom_histogram()\nHet histogram dat je net maakte, bevat de absolute frequenties op de y-as. Als je een histogram met relatieve frequenties wil plotten, dan voeg je een tweede ingrediënt (aesthetic) toe aan de ggplot()-functie: y = after_stat(density). In de code hieronder zijn nog enkele andere basisargumenten toegevoegd aan de functie geom_histogram(). Een overzicht van deze argumenten en hun betekenis vind je hier:\n\nbin: geeft het aantal bins weer dat het histogram moet bevatten. Als je dit argument of het argument binwidth niet specificeert, dan wordt het aantal bins door ggplot2 bepaald. In het voorbeeld besliste ggplot2 om 30 bins te plotten. (Dat was de boodschap die ggplot2 je hierboven meegaf.)\n\nbinwidth: geeft de breedte van de bins in het histogram weer. Als je het argument binwidth gebruikt, wordt de waarde van bins genegeerd.\n\nfill: bepaalt de opvulkleur van het histogram.\n\ncolor: bepaalt de kleur van de lijn rondom het histogram.\n\nLaat de code hieronder lopen en bekijk het histogram. Speel vervolgens met de waarden van de argumenten bins, binwidth, fill en color en kijk wat er gebeurt.\n\n\n\n\n\n\n\n\n1.3 Breaks op de x- en y-as specificeren\nTot nu toe bepaalde ggplot2 zelf de breaks (intervallen) op de x- en de y-as. Je kan deze breaks echter ook zelf specificeren. Daarvoor maak je gebruik van de functies scale_x_continuous() en scale_y_continuous(). Je voegt aan beide functies het argument breaks = ... toe. Op de plaats van de drie puntjes geef je dan aan welke breaks er moeten worden geplot.\nDe code hieronder geeft bijvoorbeeld aan dat op de x-as breaks de volgende breaks moeten worden geplaatst: 170, 180, 190, 200, 210, 220 en 230. Je zou deze breaks kunnen specificeren met de functie c(170, 180, 190, 200, 210, 220, 230), maar het is veel handiger om daarvoor de functie seq(170, 230, 10) te gebruiken. Op de y-as wordt er ook een sequentie van breaks in sprongen van 10 geplot (seq(10, 50, 10)). Aan deze sequentie wordt echter nog de waarde 57 toegevoegd (met de functie c()). Deze waarde is informatief, want het is de hoogste waargenomen absolute frequentie.\nLaat de code hieronder lopen en bekijk het histogram. Specificeer zelf andere breaks en bekijk het effect ervan. (Merk op dat dit terug een histogram is dat de absolute frequentie voorstelt.)\n\n\n\n\n\n\nJe hebt misschien opgemerkt dat er nog een argument is toegevoegd aan geom_histogram(): alpha = .8. Met dit argument bepaal je de transparantie van het histogram (meer specifiek van de fill-color). Standaard is de waarde voor dit argument 1 (niet-transparant). Door een waarde lager dan 1 mee te geven, verhoog je dus de transparantie van het histogram. Met de theme()-functie kan je de lay-out van de plot aanpassen. In dit geval zijn een deel van de gridlijnen (‘minor’ gridlijnen) verwijderd (panel.grid.minor = element_blank) en ook de belangrijkste gridlijnen (‘major’ gridlijnen) vertrekkend vanuit de x-as verwijderd (panel.grid.major.x = element_blank). In hoofdstuk 5 gaan we dieper in op de theme()-functie.\n\n\n1.4 Titel, subtitel en titel van de assen toevoegen\nVia de functie labs() kan je de labels van zowel de titel (title), subtitel (subtitle), als de namen van de x- en y-as aanpassen. Vul de code hieronder aan met gepaste titels voor de x-as, de y-as en het histogram zelf.\n\n\n\n\n\n\nAan de theme()-functie zijn nog twee argumenten toegevoegd om de lay-out van de tekst in de titel (plot.title = element_text(face = \"bold\")) en de subtitel (plot.subtitle = element_text(face = \"italic\")) aan te passen.",
    "crumbs": [
      "Visualiseren van één numerieke variabele"
    ]
  },
  {
    "objectID": "02_numeriek.html#sec-boxplot",
    "href": "02_numeriek.html#sec-boxplot",
    "title": "Eén numerieke variabele visualiseren",
    "section": "2 Boxplot",
    "text": "2 Boxplot\nEen andere mogelijkheid om de verdeling van de variabele flipper-_length_mm te visualiseren is een boxplot. Een voorbeeld van een boxplot vind je hieronder.\n\n\n\n\n\n\n\n\n\n\n2.1 Boxplot met geom_boxplot()\nOm een boxplot te maken, gebruik je de functie geom_boxplot(). Deze functie heeft één ingrediënt (aesthetic) nodig: een x-variabele (x = flipper_length_mm) of een y-variabele (y = flipper_length_mm).\nKopieer de code hieronder naar een script in RStudio op je eigen laptop en probeer de code uit. Zorg dat de packages tidyverse en palmerpenguins geladen zijn. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug. Test ook uit wat er gebeurt als je de x in de functie aes() in een y verandert.\n\nCodePlot\n\n\n\nggplot(\n  data = penguins,\n  aes(\n    x = flipper_length_mm,\n    )\n  ) +\n  geom_boxplot() +\n  labs(\n    x = \"Vleugellengte (in mm)\",\n    title = \"Boxplot van de verdeling van de variabele 'flipper_length_mm'\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.2 Basisargumenten geom_boxplot()\nIn het staafdiagram hieronder zijn er vier argumenten toegevoegd aan de functie geom_bar():\n\noutliers: geeft aan of er al dan niet outliers geplot moeten worden (TRUE or FALSE).\n\noutlier.color: bepaalt de kleur van outliers.\n\nfill: bepaalt de opvulkleur van de boxplot.\n\ncolor: bepaalt de kleur van de lijn rondom de boxplot.\n\nalpha: bepaalt de transparantie van de box van de boxplot (niet-transparant = 1, volledig transparant = 0).\n\nLaat de code hieronder lopen en bekijk de boxplot. Speel met de waarden van de argumenten fill, color en alpha en kijk wat er gebeurt. (Er zijn geen outliers! Spelen met de waarde van de argumenten outliers en outlier.color heeft in dit geval dus geen zin.)\n\n\n\n\n\n\n\n\n2.3 De x-as aanpassen\nOm de breaks op de x-as aan te passen, maken we opnieuw gebruik van de functie scale_x_continuous() en het argument breaks. Specificeer dit argument in de code hieronder zodanig dat de breaks starten op 170 en tot 230 doorlopen met sprongen van 5. Door ook het argument position = \"top\" aan de functie scale_x_continuous() toe te voegen wordt de x-as bovenaan de boxplot geplaatst.\n\n\n\n\n\n\nOmdat de waarden op de y-as dragen weinig informatief zijn, zijn deze verwijderd door het argument axis.text.y = element_blank() toe te voegen aan de theme()-functie. Ook de titel van de y-as is daarom verwijderd (axis.title.y = element_blank())\n\n\n2.4 De data toevoegen met geom_jitter()\nEen boxplot communiceert de verdeling van de variabele flipper_length_mm door enkele kengetallen samen te vatten. Dit maakt dat de onderliggende patronen in de data verborgen blijven. De onderstaande boxplots lijken identiek, maar ze verbergen een heleboel zaken. Je kan bijvoorbeeld niet aflezen hoe groot de steekproef is waarop elke boxplot gebaseerd is.\n\n\n\n\n\n\n\n\n\nOok de verdeling van de data zelf blijft onzichtbaar in een boxplot. Om dit op te lossen, kan je de data zelf ook toevoegen aan de boxplot. Dit kan je doen met behulp van geom_point() of geom_jitter(). Hieronder vind je een voorbeeld van beiden.\n\n# maak een plot met geom_point en schrijf deze weg in het object plot_point\nplot_point &lt;- ggplot(\n  data = penguins,\n  aes(\n    x = flipper_length_mm\n    )\n  ) +\n  geom_boxplot(\n    outliers = TRUE,\n    outlier.color = \"darkred\",\n    fill = \"grey\",\n    color = \"black\",\n    alpha = 0.8\n  ) +\n  geom_point(\n    aes(y = 0),\n    shape = 1,\n    alpha = 0.3\n    ) +\n  scale_x_continuous(\n    breaks = seq(170, 230, 10),\n    position = \"top\"\n  ) + \n  labs(\n    x = \"Vleugellengte (in mm)\",\n    title = \"Data geplot met geom_point\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    axis.title.y = element_blank(),\n    axis.text.y = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor = element_blank()\n  )\n\n# maak een plot met geom_jitter en schrijf deze weg in het object plot_point\nplot_jitter &lt;- ggplot(\n  data = penguins,\n  aes(\n    x = flipper_length_mm\n    )\n  ) +\n  geom_boxplot(\n    outliers = TRUE,\n    outlier.color = \"darkred\",\n    fill = \"grey\",\n    color = \"black\",\n    alpha = 0.8\n  ) +\n  geom_jitter(\n    aes(y = 0),\n    height = .1,\n    shape = 1,\n    alpha = .3\n    ) +\n  scale_x_continuous(\n    breaks = seq(170, 230, 10),\n    position = \"top\"\n  ) + \n  labs(\n    x = \"Vleugellengte (in mm)\",\n    title = \"Data geplot met geom_jitter\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    axis.title.y = element_blank(),\n    axis.text.y = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor = element_blank()\n  )\n\n# voeg beide plots samen tot 1 visualisatie met het package patchwork\nlibrary(patchwork)\nplot_point + plot_jitter +\n  plot_annotation(tag_levels = \"1\", tag_prefix = \"Plot \")\n\n\n\n\n\n\n\n\nHet verschil tussen beide functies is dat geom_jitter() een beetje ‘ruis’ toevoegt aan elk datapunt zodat de punten niet precies boven op elkaar geplot worden. Dat laatste is wel het geval bij het gebruik van geom_point (Plot 1). Op die manier is het moeilijk in te schatten hoeveel datapunten er zijn.\nIn de functie geom_jitter() zijn enkele extra argumenten meegegeven om de hoeveelheid ‘ruis’ om aan te geven hoeveel ruis er in de verticale richting moet worden toegevoegd (height = 0.1). Ook de grootte van elk datapunt (size = 1), de vorm die elk datapunt weergeeft (shape = 1) en de transparantie ervan (alpha = 0.3) is vastgelegd. In hoofdstuk 3 leer je meer over de verschillende vormen (‘shapes’) die beschikbaar zijn in R. Hieronder vind je de code terug waarin geom_jitter() wordt gebruikt. Speel met de waardes voor de argumenten height, size en shape en kijk wat er gebeurt!\n\n\n\n\n\n\nBen je benieuwd naar hoe verschillend of gelijkend de dataset achter de drie identieke boxplots is? Neem dan een kijkje op de blog van Cedric Schérer. Dit is één van de ggplot-wizards die regelmatig workshops geeft over ggplot2.",
    "crumbs": [
      "Visualiseren van één numerieke variabele"
    ]
  },
  {
    "objectID": "02_numeriek.html#sec-overzichtnum",
    "href": "02_numeriek.html#sec-overzichtnum",
    "title": "Eén numerieke variabele visualiseren",
    "section": "3 Overzicht van functies en argumenten uit hoofdstuk 2",
    "text": "3 Overzicht van functies en argumenten uit hoofdstuk 2\nDe onderstaande functies en argumenten zijn in dit hoofdstuk aan bod gekomen:\n\nfunctie geom_histogram() met aesthetic x en de argumenten bins, binwidth, fill, color en alpha\n\nfunctie geom_boxplot() met aesthetics x of y en de argumenten outliers, outlier.fill, fill, color en alpha\nfunctie geom_jitter() met aesthetics x en y en de argumenten height, size, shape en alpha\n\nfuncties scale_x_continuous() en scale_x_continuous() met de argumenten breaks en position.\n\nfunctie labs() met de argumenten title, subtitle, x en y\n\nDe functie theme() en de argumenten die erbij horen, komen uitgebreid aan bod in het hoofdstuk ‘Visualisatie in stijl’. Daarom worden ze hier niet opgelijst.\nLet op! De meeste functies beschikken over veel meer argumenten dan diegene die in dit hoofdstuk aan bod zijn uitgelegd. Voor een volledig overzicht van alle argumenten van een functie, kan je de help-functie gebruiken. Ook de specifieke aesthetics die je kan toevoegen aan elke *geom*-functie zijn uitgebreider dan je hier terug vindt. Daarover meer in de volgende hoofdstukken.",
    "crumbs": [
      "Visualiseren van één numerieke variabele"
    ]
  },
  {
    "objectID": "03_categorisch.html#sec-staafdiagram",
    "href": "03_categorisch.html#sec-staafdiagram",
    "title": "Eén categorische variabele visualiseren",
    "section": "1 Staafdiagram",
    "text": "1 Staafdiagram\nEen eerste mogelijkheid om de verdeling van de variabele species te visualiseren is gebruik maken van een staafdiagram. Hieronder vind je een voorbeeld van een staafdiagram die je op het einde van dit deel zal kunnen maken.\n\n\n\n\n\n\n\n\n\n\n1.1 Staafdiagram met geom_bar() of geom_col()\nOm een staafdiagram te maken kan je in ggplot gebruik maken van twee verschillende geoms: geom_bar() of geom_col(). Hieronder vind je dezelfde staafdiagram gecreërd met geom_bar() (links) of geom_col() (rechts). Vergelijk de code en probeer beide opties uit. Wat is het verschil tussen beide functies?\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(\n  data = penguins,\n  aes(\n    x = species\n    )\n  ) +\n  geom_bar() +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\ncount_data &lt;- \n  penguins %&gt;%\n  ## Tel pinguins per soort (species)\n  ## Schrijf deze weg in de kolom `count`\n  count(species, name = \"count\")\n\nggplot(\n  data = count_data,\n  aes(\n    x = species,\n    y = count\n    )\n  ) +\n  geom_col() +\n  theme_minimal()\n\n\n\nHet grote verschil tussen beide functies is dat geom_bar() op de achtergrond het telwerk voor jou uitvoert, terwijl geom_col() ervanuit gaat dat jij dat telwerk al deed. Om geom_col() te kunnen gebruiken, dien je dus een dataset aan te maken die de frequenties per pinguïnsoort bevat. Dit merk je ook aan het verschil in aesthetics. In geom_bar() wordt alleen een x-variabele gespecificeerd (de categorische variabele species). De functie geom_col() vraagt zowel om een x-variabele (de categorische variabele species) als een y-variabele (de numerieke variabele die de aantallen bevat count). Vanaf hier maken we gebruik van de functie geom_bar(). De zaken die je daarbij leert, kan je ook toepassen bij het gebruik van geom_col(). Als de toepassing voor geom_col() toch anders, is dan tonen we deze ook.\n\n\n1.2 Basisargumenten geom_bar()\nIn het staafdiagram hieronder zijn er drie argumenten toegevoegd aan de functie geom_bar():\n\nwidth: bepaalt de breedte van de staven (default = 1).\n\nfill: bepaalt de opvulkleur van de staven.\n\ncolor: bepaalt de kleur van de lijn rondom de staven.\n\nLaat de code hieronder lopen en bekijk het staafdiagram. Speel vervolgens met de waarden van de argumenten width, fill en color en kijk wat er gebeurt.\n\n\n\n\n\n\n\n\n1.3 Staven ordenen\nAls je de functie geom_bar() gebruikt, kan je de staven van groot naar klein ordenen met de functie fct_infreq(). Dit is een functie uit het package forcats, een ander package uit de tidyverse. (Als je in het begin van je R-sessie het package tidyverse laat, staan dus ook de functies uit het package forcats klaar voor gebruik.) Om deze functie te kunnen gebruiken, dient de variabele species als factor in de dataset te zitten (wat al het geval is). De functie fct_infreq() zorgt ervoor dat de levels van de factor geplot worden volgens de frequentie waarmee ze voorkomen.\nAls je de code hieronder laat lopen, zal je vaststellen dat de meest voorkomende pinguïnsoort Adélie is, gevolgd door Gentoo en Chinstrap. Wil je de staven van klein naar groot ordenen? Vervang dan fct_rev() in de code hieronder door fct_rev(fct_infreq(species)) en run de code opnieuw.\n\n\n\n\n\n\nGebruik je de functie geom_col() om een staafdiagram te maken? Dan hanteer je de functie reorder() zoals in het voorbeeld hieronder. De staven worden nu van klein naar groot georderd. Wil je de volgorde omdraaien? Plaats dan een - voor count (x = reorder(species, -count)). Probeer beide mogelijkheden uit.\n\n\n\n\n\n\n\n\n1.4 Titel, subtitel en titel van de assen toevoegen\nVia de functie labs() kan je de labels van zowel de titel (title), subtitel (subtitle), als de namen van de x- en y-as aanpassen. Bedenk gepaste titels voor de staafdiagram over het aantal pinguïns per soort en vul de code hieronder aan.\n\n\n\n\n\n\nAan de theme()-functie zijn twee argumenten toegevoegd om de lay-out van de tekst in de titel (plot.title = element_text(face = \"bold\")) en de subtitel (plot.subtitle = element_text(face = \"italic\")) aan te passen.\n\n\n1.5 De staven labelen\nTot nu toe moest de kijker de hoogte van de staven zelf aflezen op de y-as. Soms is het echter handig om boven elke staaf het aantal pinguïns te zetten. Dit kan je doen door een tweede geom te gebruiken: geom_text(). Je dient daarbij aan te geven welk label boven elke staaf geplaatst moet worden. Dat doe je door aes(label = after_stat(count)) toe te voegen aan geom_text(). Het stukje count uit de code verwijst naar het getelde aantal pinguïns dat ggplot2 op de achtergrond heeft berekend. Je dient geom_text() ook mee te geven welke variabele er op de x-as moet komen. In de code hieronder is er echter geen x aesthetic meegegeven. In dat geval ‘erft’ geom_text() de aesthetics van de ggplot()-functie.\nDe betekenis van de drie andere argumenten die zijn toegevoegd aan geom_text() wordt hieronder uitgelegd:\n\nstat: geeft aan wat er precies boven de staaf geplaatst moet worden.\nvjust: de verticale positie van het label (0 = precies op de bovenkant van de staaf, &gt; 0 boven de staaf, &lt; 0 = onder de bovenkant van de staaf).\nsize: bepaalt de grootte van de letters.\ncolor: bepaalt de kleur van de letters.\n\nPas de waarden van de verschillende argumenten in de code hieronder aan en kijk wat er gebeurt.\n\n\n\n\n\n\nJe hebt misschien opgemerkt dat er nog een beetje code is toegevoegd aan de theme()-functie. Met deze code zijn alle gridlijnen verwijderd (panel.grid = element_blank()) en is ook de titel van de y-as (axis.title.y = element_blank()) en de labels op de y-as verwijderd (axis.text.y = element_blank()).\nAls je geom_col() gebruikt, dan gebruik je andere code voor het toevoegen van de labels met getallen. Deze code vind je terug in het luikje rond het toevoegen van labels met getallen aan een dotplot (zie Sectie 2.4).\n\n\n1.6 De assen van plaats veranderen\nAls de waarden van de variabele op de x-as heel lang zijn, is het handig om de x- en y-as van plaats te veranderen. (Denk bijvoorbeeld aan de labels van een Likert schaal: “Helemaal niet akkoord”.) Door de assen van plaats te veranderen blijft de leesbaarheid van die waarden optimaal. Om de assen van plaats te veranderen, bestaat er een handige functie in ggplot2: coord_flip().\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Zorg dat de packages tidyverse en palmerpenguins geladen zijn. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n  data = penguins,\n  aes(\n    x = fct_infreq(species)\n    )\n  ) +\n  geom_bar(\n    width = .5,\n    fill = \"grey\",\n    color = \"black\"\n  ) +\n  geom_text(\n    aes(label = ..count..),\n    stat = \"count\",\n    hjust = -0.2, ## vjust wordt hjust\n    size = 3,\n    color = \"black\"\n    ) +\n  labs(\n    x = \"Pinguïnsoort\",\n    y = \"Aantal\",\n    title = \"Staafdiagram van aantal pinguïns per soort\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\"\n  ) +\n  coord_flip() +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\"),\n    panel.grid = element_blank(),\n    axis.text.y = element_blank()\n  )\n\n\n\n\n\nWarning: The dot-dot notation (`..count..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(count)` instead.",
    "crumbs": [
      "Visualiseren van één categorische variabele"
    ]
  },
  {
    "objectID": "03_categorisch.html#sec-dotplot",
    "href": "03_categorisch.html#sec-dotplot",
    "title": "Eén categorische variabele visualiseren",
    "section": "2 Dotplot",
    "text": "2 Dotplot\nEen andere mogelijkheid om de verdeling van het aantal pinguïns per soort te visualiseren is een dotplot. Hieronder vind je een voorbeeld van een dotplot.\n\n\n\n\n\n\n\n\n\nIn ggplot2 maak je een dotplot met behulp van geom_point().\n\n2.1 Dotplot met geom_point()\nVooraleer je de dotplot kan maken, dien je eerst een dataset aan te maken die de frequenties per pinguïnsoort bevat (net zoals bij het maken van een staafdiagram met geom_col()). Deze dataset kan je vervolgens gebruiken om de dotplot te maken. Daarbij plaats je pinguïnsoort (species) op de x-as en het aantal pinguïns (count) op de y-as. De rest van de code zou je bekend moeten voorkomen. Deze is overgenomen van de code om een staafdiagram te maken.\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\ncount_data &lt;-\n  penguins %&gt;%\n  count(species, name = \"count\")\n\nggplot(\n  data = count_data,\n  aes(\n    x = species,\n    y = count\n    )\n  ) +\n  geom_point(\n  ) +\n  labs(\n    x = \"Pinguïnsoort\",\n    y = \"Aantal\",\n    title = \"Dotplot van aantal pinguïns per soort\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.2 Basisargumenten geom_point()\nIn de dotplot hieronder zijn er vier argumenten toegevoegd aan de functie geom_point():\n\nshape: bepaalt de vorm van de punten en wordt aangegeven met een getal. Hier vind je een overzicht van de beschikbare vormen in R. Afhankelijk van de vorm is het mogelijk om een kleur (color) en/of vulling (fill) te bepalen.\n\nsize: bepaalt de grootte van de punten (default = 0.5)\n\ncolor: bepaalt de kleur van de lijn rond de punten (voor vormen 1 t.e.m. 14 en 21 t.e.m. 25)\n\nfill: bepaalt de opvulkleur van de punten (voor vormen 15 t.e.m. 25)\n\nLaat de code hieronder lopen en bekijk de dotplot. Speel vervolgens met de waarden van de verschillende argumenten en kijk wat er gebeurt.\n\n\n\n\n\n\n\n\n2.3 Dots ordenen\nJe kan de dots ook ordenen volgens grootte door de functie reorder() toe te voegen (x = reorder(species, count)) aan de x-aesthetic, analoog aan hoe we dit deden bij het maken van een geordende staafdiagram met geom_col(). De richting veranderen doe je door een “-” voor count te plaatsen (x = reorder(species, -count)).\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n  data = count_data,\n  aes(\n    x = reorder(species, count),\n    y = count\n    )\n  ) +\n  geom_point(\n    shape = 21,\n    size = 2,\n    color = \"black\",\n    fill = \"steelblue\"\n  ) +\n  labs(\n    x = \"Pinguïnsoort\",\n    y = \"Aantal\",\n    title = \"Dotplot van aantal pinguïns per soort\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.4 De dots labelen\nNet zoals bij het staafdiagram kan je de dots ook rechtsstreeks labelen door geom_text() toe te voegen aan de code. Hierbij wordt aangegeven dat de variabele count uit de dataset count_data moet worden gebruikt om de dots te labelen (aes(label = count)). Om ervoor te zorgen dat het label van de bovenste dot volledig wordt geplot, zijn de limieten van de y-as aangepast. Deze limieten geven aan wat de minimale en maximale waarde is die op de y-as wordt weergegeven. Daarom is ook de functie scale_y_continuous() toegevoegd aan de plot met als argument de juiste limieten (limits = c(0, 154)). In de functie wordt verder ook aangegeven dat er geen titel bij de y-as moet worden geplaatst (name = NULL). (De naam van de y-as is ook verwijderd uit de functie labs().) Speel met de limieten van de y-as in de code hieronder en kijk wat er gebeurt met de dotplot.\n\n\n\n\n\n\n\n\n2.5 Dots inkleuren volgens pinguïnsoort\nTot nu toe hebben we alle dots dezelfde kleur gegeven. Het is echter ook mogelijk om de dots in te kleuren volgens pinguïnsoort. Het enige dat we daarvoor dienen te doen, is twee ‘ingrediënten’ (aesthetics) toevoegen aan de dotplot. In de code hieronder vind je deze extra aesthetics terug in de aes()-functie (color = species en fill = species). We voegen hier zowel color als fill toe, omdat de shape die we gebruiken (shape ‘21’) een aparte kleur voor de vulling (fill) en voor de omtrek (color) toelaat. Vergeet ook niet om de argumenten voor color en fill die in geom_point() stonden weg te halen. Als je dat laatste niet doet, dan gebruikt ggplot2 de argumenten die in geom_point() staan (omdat deze argumenten verderop in de code staan en dus als laatste geëvalueerd worden).\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\nggplot(\n  data = count_data,\n  aes(\n    x = reorder(species, count),\n    y = count,\n    color = species,\n    fill = species\n    )\n  ) +\n  geom_point(\n    shape = 21,\n    size = 2\n  ) +\n  geom_text(\n    aes(label = count),\n    vjust = -0.5,\n    size = 3,\n    color = \"grey50\"\n  ) +\n  scale_y_continuous(\n    limits = c(0, 154),\n    name = NULL\n    ) +\n  labs(\n    x = \"Pinguïnsoort\",\n    y = \"Aantal\",\n    title = \"Dotplot van aantal pinguïns per soort\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\"),\n    panel.grid = element_blank(),\n    axis.text.y = element_blank(),\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJe kan de kleuren zelf aanpassen met behulp van de functie scale_color_manual() (om de omtrek van de dots in te kleuren naar species) en scale_fill_manual() (om de opvulling van de dots in te kleuren naar species). Beide functies hebben één argument: values = c(\"darkorange\",\"purple\",\"cyan4\").",
    "crumbs": [
      "Visualiseren van één categorische variabele"
    ]
  },
  {
    "objectID": "03_categorisch.html#sec-lollipop",
    "href": "03_categorisch.html#sec-lollipop",
    "title": "Eén categorische variabele visualiseren",
    "section": "3 Lollipop plot",
    "text": "3 Lollipop plot\nEen dotplot is een goede opstap naar een lollipop plot. Hieronder vind je een voorbeeld van zo’n plot.\n\n\n\n\n\n\n\n\n\n\n3.1 Lollipop plot met geom_point() en geom_segment()\nAls je de code hieronder bekijkt, dan zal je merken dat er eigenlijk maar een beetje extra code is toegevoegd aan de code voor de dotplot. We vertrekken nog steeds van de count_data en de staven van de lollipop plot worden geordend op frequentie (x = reorder(species, count)). Om een lollipop plot te creëren, dien je verder alleen de geom geom_segment() toe te voegen. Deze geom plot een lijn (een segment) en heeft vier ingrediënten (aesthetics) nodig om te kunnen werken. De argumenten x en xend geven het start- en eindpunt van de lijn op de x-as weer. In dit geval is de variabele op de x-as categorisch van aard (species). Je geeft deze variabele dan op als start- én eindpunt. De argumenten y en yend doen hetzelfde maar dan voor de y-as. In een lollipop plot vertrekt de lijn steeds vanuit 0 (y = 0) en heeft als eindpunt de frequentie van het aantal pinguïns (voor die soort). Aangezien die laatsten vervat zijn in de variabele count plaats je deze achter yend.\nKopieer de code hieronder naar RStudio op je eigen laptop en probeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\ncount_data %&gt;%\n  ggplot(\n    aes(\n      x = reorder(species, count),\n      y = count\n      )\n    ) + \n  geom_point( \n  ) +  \n  geom_segment(  \n    aes(\n      x = species,\n      xend = species, \n      y = 0,\n      yend = count\n      )\n    ) +\n   labs(\n    x = \"Pinguïnsoort\",\n    y = \"Aantal\",\n    title = \"Dotplot van aantal pinguïns per soort\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.2 De dots labelen\nDe dots kunnen opnieuw gelabeld worden. Kopieer daarover de nodige code (zie Sectie 2.4) en plak deze in het codeblock hieronder. De code om de titel van de y-as, de labels op de y-as en de gridlijnen te verwijderen, is al toegevoegd (scale_y_continuous(name = NULL)).\n\n\n\n\n\n\n\n\n3.3 Inkleuren volgens pinguïnsoort\nDe lollipop plot kan vervolgens ook ingekleurd worden volgens pinguïnsoort. Daartoe dienen we twee extra aesthetics toe te voegen aan de ggplot()-functie: color = species en fill = species. Door dit in de ggplot()-functie toe te voegen, zal dit worden toegepast op alle geoms die we verder gebruiken. M.a.w. zowel in geom_point() als geom_segment() worden de geoms nu ingekleurd volgens pinguïnsoort. Merk op dat we ook de functie scale_color_manual() toevoegde aan de code.\nKopieer de code hieronder naar RStudio op je eigen laptop enprobeer deze uit. Door hieronder op ‘Plot’ te klikken, vind je het verwachte resultaat terug.\n\nCodePlot\n\n\n\ncount_data %&gt;%\n  ggplot(\n    aes(\n      x = reorder(species, count),\n      y = count,\n      color = species,\n      fill = species\n      )\n    ) + \n  geom_point( \n  ) +  \n  geom_segment(  \n    aes(\n      x = species,\n      xend = species, \n      y = 0,\n      yend = count\n      )\n    ) +\n  geom_text(\n    aes(label = count),\n    vjust = -0.5,\n    size = 3,\n    color = \"grey50\"\n  ) +\n  scale_y_continuous(name=NULL) +\n  labs(\n    x = \"Pinguïnsoort\",\n    title = \"Dotplot van aantal pinguïns per soort\",\n    subtitle = \"Gebaseerd op observaties in 2007, 2008 en 2009\"\n  ) +\n  scale_color_manual(\n    values = c(\"darkorange\",\"purple\",\"cyan4\")\n) +\n  scale_fill_brewer(\n    values = c(\"darkorange\",\"purple\",\"cyan4\")\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\"),\n    panel.grid = element_blank(),\n    axis.text.y = element_blank(),\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.4 Labels bij dots inkleuren\nZowel de lijnen als punten van de lollipop plot zijn ingekleurd volgens pinguïnsoort. Je vindt het misschien vreemd dat de tekst bij de dots nog steeds in het grijs is? Hierboven gaven we immers aan dat het toevoegen van color = species en fill = species aan de ggplot()-functie ervoor zorgt dat dit op alle geoms wordt toegepast. Waarom is dit dan niet togepast op geom_text()? Hieronder vind je de code terug. Welke codelijn moet je schrappen om ervoor te zorgen dat ook de labels bij de dots in de juiste kleur worden geplot? Schrap die code en probeer dit uit.\n\n\n\n\n\n\nDoor color = \"grey50\" als argument te verwijderen uit geom_text() worden ook de labels van de dots in de juiste kleur geplot. Dit argument zorgde er immers voor dat het color- en fill-argument uit de ggplot()-functie werd ‘overruled’. Je hebt misschien ook gemerkt dat de legende verdwenen is? Dit kan door het argument legend.position = \"none\" toe te voegen aan theme(). De legende verwijderen is hier mogelijk gemaakt door de labels op de x-as naar boven te verplaatsen. Voor dat laatste werd de functie scale_x_discrete() gebruikt (scale_x_discrete() en niet scale_x_continuous() omdat de variabele op de x-as categorisch van aard is). Met het argument position = \"top\" geef je aan dat je wil dat de x-as bovenaan de plot wordt geplaatst.",
    "crumbs": [
      "Visualiseren van één categorische variabele"
    ]
  },
  {
    "objectID": "03_categorisch.html#overzicht-van-functies-en-argumenten-uit-hoofdstuk-3-sec-overzichtcat",
    "href": "03_categorisch.html#overzicht-van-functies-en-argumenten-uit-hoofdstuk-3-sec-overzichtcat",
    "title": "Eén categorische variabele visualiseren",
    "section": "4 Overzicht van functies en argumenten uit hoofdstuk 3 (?@sec-overzichtcat)",
    "text": "4 Overzicht van functies en argumenten uit hoofdstuk 3 (?@sec-overzichtcat)\nDe onderstaande functies en argumenten zijn in dit hoofdstuk aan bod gekomen:\n\nfuncties geom_bar() en geom_col() met aesthetics x, y, color en fill en de argumenten width, fill en color\n\nfunctie geom_text() en de argumenten label, stat, vjust, size en color\nfunctie geom_point() en de argumenten shape, size, fill en color\n\nfunctie geom_segment() en de argumenten x, xend, y en yend\n\nfuncties scale_x_discrete() en scale_y_continuous() met de argumenten limits en name\n\nfunctie scale_color_manual() met het argument values\nfunctie labs() met de argumenten title, subtitle, x en y\nfunctie coord_flip()\nfuncties fct_infreq() en fct_rev()\nfunctie reorder()\n\nDe functie theme() en de argumenten die erbij horen, komen uitgebreid aan bod in het hoofdstuk ‘Visualisatie in stijl’. Daarom worden ze hier niet opgelijst.\nLet op! De meeste functies beschikken over veel meer argumenten dan diegene die in dit hoofdstuk aan bod zijn uitgelegd. Voor een volledig overzicht van alle argumenten van een functie, kan je de help-functie gebruiken. Ook de specifieke aesthetics die je kan toevoegen aan elke *geom*-functie zijn uitgebreider dan je hier terug vindt. Daarover meer in de volgende hoofdstukken.",
    "crumbs": [
      "Visualiseren van één categorische variabele"
    ]
  }
]